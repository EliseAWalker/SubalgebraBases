debug Core -- gets rid of "raw" error during installation. probably a better way...

export {
    "subalgebraBasis",
    "subduction",
    "sagbi" => "subalgebraBasis",
    "PrintLevel",
    "SagbiDegrees",
    "SubalgComputations",
    "SagbiGens",
    "SagbiDone",
    "appendToBasis" -- temporary
    }

-- A wrapper around rawSubduction. Intended for internal use only.
   -- M should be a 1-row matrix with entries in the tensor ring of subR.
subduct = method(TypicalValue => Matrix)
subduct(Subring, Matrix) := (subR, M) -> (   
    ambR := ambient subR;
    
    if entries M === {{}} then (
	return M;
	);
    subalgComp := subR.cache.SubalgComputations;
    -- Substitution encodes the set used as the subalgebra basis.
    sagbiPres := subalgComp#"SagbiPres";
    F := sagbiPres#"Substitution";
    J := subalgComp#"sagbiGB";
    numblocks := rawMonoidNumberOfBlocks raw monoid ambR;
    rawSubduction(numblocks, raw M, raw F, raw J)
    );

-- Performs subduction relative to a given set. This set need not be a Sagbi basis.
-- If S is a Sagbi basis, the result is zero IFF f is an element of the subalgebra generated by S. 
   -- S is a set of RingElements (as in Robbiano and Sweedler.)
   -- f is a RingElement to perform subduction on, relative to S.
subduction = method(TypicalValue => RingElement)
subduction(Matrix, RingElement) := (S, f) -> (
    subR := subring S;
    
    presS := makePresRing(S);

    F := presS#"Substitution";
    J := gb(presS#"SyzygyIdeal");
    numblocks := rawMonoidNumberOfBlocks raw monoid ambient subR;
    fMat := matrix({{presS#"InclusionBase"(f)}});    
    result := rawSubduction(numblocks, raw fMat, raw F, raw J);
    result = promote(result_(0,0), source (presS#"ProjectionBase"));
    result = presS#"ProjectionBase"(result);
    
    result
    );

-- Performs subduction using the generators of subR.
-- currently does not require the generators to be a Sagbi basis.
subduction(Subring, RingElement) := (subR, f) -> (
    
    if (ring f) =!= (ambient subR) then()(
	error "The given RingElement must be from the ambient ring of the the given Subring instance."; 
	);
    
    presSubR := makePresRing(subR);
    
    F := presSubR#"Substitution";
    J := gb(presSubR#"SyzygyIdeal");
    numblocks := rawMonoidNumberOfBlocks raw monoid ambient subR;
    fMat := matrix({{presSubR#"InclusionBase"(f)}});    
    result := rawSubduction(numblocks, raw fMat, raw F, raw J);
    result = promote(result_(0,0), source (presSubR#"ProjectionBase"));
    result = presSubR#"ProjectionBase"(result);
    
    result
    );

subalgebraBasis = method(Options => {
    Strategy => null,
    Limit => 100,
    PrintLevel => 0})

subalgebraBasis List := o -> L -> (
    subalgebraBasis(o, subring L)
    );

subalgebraBasis Subring := o -> R -> (
    R.cache.SubalgComputations = new MutableHashTable;
    subalgComp := R.cache.SubalgComputations;
    
    R.cache.SagbiDegrees = {};
    subalgComp#"sagbiGB" = null;
    
    currDegree := null;     -- d
    nLoops := null;         -- nloops
    R.cache.SagbiDone = false;
    syzygyPairs := null;
    newElems := null;
    
    subalgComp#"Pending" = new MutableList from toList(o.Limit+1:{});
    R.cache.SagbiGens = matrix(ambient R,{{}});

    -- Get the maximum degree of the generators. This is used as a stopping condition.
    maxGensDeg := (max degrees source gens R)_0;

    -- Only look at generators below degree limit.  Add those generators to the SubalgebraGenerators
    reducedGens := compress submatBelowDegree(gens R, o.Limit+1);
    insertPending(R, reducedGens, o.Limit);
    -- Remove elements of coefficient ring
    (subalgComp#"Pending")#0 = {};
    processPending(R, o.Limit);
    currDegree = subalgComp#"CurrentLowest" + 1;
    
    isPartial := false;
    
        
    while currDegree <= o.Limit and not R.cache.SagbiDone do (  	
        -- Construct a Groebner basis to eliminiate the base elements generators from the SyzygyIdeal.
	-- SyzygyIdeal is an ideal consisting of (variables repesenting subalgebra generators) minus (their leading term). 
	
	pres := subalgComp#"SagbiPres";
	subalgComp#"sagbiGB" = gb(pres#"SyzygyIdeal", DegreeLimit => currDegree);
	
	-- This will select the entries of sagbiGB that do not involve any of (leadTerms subalgComp#"SyzygyIdeal") and also
	-- have degree equal to currDegree. So, they will be exclusively in the higher block of variables of TensorRing.
	zeroGens := submatByDegree(mingens ideal selectInSubring(1, gens (subalgComp#"sagbiGB")), currDegree);
	    		
	-- Plug the generators into the degree currDegree polynomials that eliminate the lead terms (I.e. zeroGens.) 
	-- This changes it from a polynomial in the generators to a polynomial in the variables of the ambient ring.
       	syzygyPairs = pres#"Substitution"(zeroGens);

	-- Have we previously found any syzygies of degree currDegree?
        if subalgComp#"Pending"#currDegree != {} then (
            syzygyPairs = syzygyPairs | pres#"InclusionBase"(matrix{subalgComp#"Pending"#currDegree});
            subalgComp#"Pending"#currDegree = {};
            );
	
       	subd := subduct(R, syzygyPairs);
	
       	if entries subd != {{}} then (
	    -- converts back to the variables of the ambient ring.
	    subducted := (pres#"ProjectionBase")(map(pres#"TensorRing",subd));
	    newElems = compress subducted;
            ) else (
	    newElems = subd;
	    );
	
	if numcols newElems > 0 then (
	    -- Put newElems in pending and update subalgComp. 
            insertPending(R, newElems, o.Limit);
    	    processPending(R, o.Limit);
	    currDegree = subalgComp#"CurrentLowest";
            ) else (
	    -- "rawStatus1 raw (subalgComp#"sagbiGB") == 6" means that the GB is a complete GB (as if DegreeLimit was not specified.)
	    if sum toList apply(subalgComp#"Pending", i -> #i) == 0 and rawStatus1 raw (subalgComp#"sagbiGB") == 6 and currDegree > maxGensDeg then (
                R.cache.SagbiDone = true;
                if (o.PrintLevel > 0) then (
		    print("Finite SAGBI basis was found.");
		    );
            	);
            );
	currDegree = currDegree + 1;
    	);
    
    if currDegree > o.Limit then(
	isPartial = true;
	);
    -- Possibly, it could finish on the same run that it successfully terminates.
    if R.cache.SagbiDone == true then(
	isPartial = false;
	);
    
    if currDegree > o.Limit and o.PrintLevel > 0 then (
	print("Limit was reached before a finite SAGBI basis was found.");
    	);
    

    -- We return a new instance of subring instead of the generators themselves so that we can say whether or not a Subring instance
    -- IS a Sagbi basis, not whether or not it HAS a Sagbi basis. (The latter is unacceptable because the cache should not effect 
    -- the value of a function.)
        
    -- If subalgebraBasis is called on a Subring instance with a previously computed Sagbi basis that is not itself a Sagbi basis,
    -- a new subring instance will be constructed from its cached SagbiGens. This is OK because different instances of the same 
    -- subring will still be equal if we calculate equality based on the mathematical equality of the subalgebras they generate.
    -----------------------------------------------------------------------------------------------------
    -- subR.cache.SagbiDone: Indicates whether or not the Subring instance has a cached Sagbi basis. 
    -- subR.isSagbi        : Indicates whether or not (gens subR) itself is a Sagbi basis.
    -----------------------------------------------------------------------------------------------------
    -- The correct way to implement a function that requires a Subring instance that is a Sagbi basis is to check that 
    -- (subR.isSagbi == true). If (subR.isSagbi == false) and (subR.cache.SagbiDone == true), an error should be thrown.
    
    M := R.cache.SagbiGens;
    
    -- We shouldn't directly set (cache => R.cache) because there is the possibility of inhereting outdated information. 
    cTable := new CacheTable from{
	SubalgComputations => new MutableHashTable from {},
	SagbiGens => M,
	SagbiDegrees => R.cache.SagbiDegrees,
	SagbiDone => R.cache.SagbiDone
	}; 
    new Subring from {
    	"AmbientRing" => ambient R,
    	"Generators" => M,
	"PresRing" => makePresRing(ambient R, M),
    	"isSagbi" => R.cache.SagbiDone,
	"isPartialSagbi" => isPartial,
	"partialDegree" => currDegree-1,
	cache => cTable
	} 
    );

subalgebraBasis Matrix := o -> gensMatrix -> (
    R := subring gensMatrix;
    subalgebraBasis(R,o)
    );
