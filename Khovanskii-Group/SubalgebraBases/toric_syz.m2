
export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "isSubalg"
    }

isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));





-- This is subroutine 11.14 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- f is an element of subR. Hence, it is a polynomial in the upper variables of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    if projInc G != G then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    if projInc p != p then(
	error "p must be a polynomial in the generators of subR."
	);
    
    -- The ordering inside K[F] should be induced by the ordering on the ambient ring.
    -- The tensor ring has a GrevLex on the variables corresponding to generators.
    -- Make sure to use the induced order, not the GRevLex order. 
    fullSub := pres#"FullSub";
    inG := leadTerm fullSub G;
    result := fullSub p;
    amb := ambient subR;
    
    print("-- Exponent vectors of the lead terms of gens subR::");
    for i from 0 to (numgens subR) - 1 do(
	print(toString(i)|":"|toString(first exponents (first entries leadTerm gens subR)#i));	
	);
    print("--------------------------------------------");
    
    -- As an ideal of the ambient ring, inG may be larger than it is as an ideal of subR.
    -- We have to construct the ideal as a subalgebra because we will need to test membership later.
    inGSubring := subring(inG**gens(subR));
    
    -- Why isn't this true?
    ans := isSubalg(inGSubring, subR);
    -- Perhaps // and % are broken? Let's see...
    A := (gens inGSubring)%subR;
    B := (gens inGSubring)//subR;
    C := fullSub(A) + fullSub(B);
    I := pres#"LiftedPres";
    -- We expect that the elements of A are not elements of subR.
    assert(A%subR == A);   
    -- As we'd also expect, B is a member of the subalgebra because it's a polynomial in the generators.
    assert(selectInSubring(1, B) == B);
    -- They should be related by the equation f = a + r w/ a in A, r "minimal."
    -- If this succeeds, the only way subduction is wrong is if r is not "minimal."
    assert(gens inGSubring == fullSub(A) + fullSub(B));
    
    print("-- assertions complete");
    error "stop";
    
    
    loopNum := 0;
    while true do (
	-- find a term tb of result that lies in the ideal in(G), halt if there is none.
      	
	--badTerms := result - (result % ideal(inG));
    	badTerms := result - (inGSubring#"PresRing"#"FullSub")(result % inGSubring);
	
	if badTerms == 0_amb then(
	    break;
	    );
	-- we can operate on any one of the monomials of badTerms. Arbitrarily use the lead term.
	tb := leadTerm badTerms;
	print("-- Term to eliminate:");
	print(toString(loopNum)|":"|toString(first exponents tb));
	
	-- find an element g of G such that tb lies in <in_w(G)>
	g := 0_amb;
	for i from 0 to (numcols inG) - 1 do(
	    elt := inG_(0,i);
	    if gcd(elt, tb) == elt then (
		g = elt;
		break;
		); 
	    );
        if g == 0_amb then(
	    error "Unknown failure (gens subR is not a Sagbi basis?)";
	    ); 	
	
       	v := first ((exponents tb) - (exponents g));
	
	-- Find an element of subR whose lead term has exponent vector v.
	-- This is equivalent to solving a certain integer program, and it can be done by computing a GB.
	-- In the notation of Kreuzer and Robbiano tutorial 36, v is the exponent vector of sum{y_{i}^{b_i}}.
	-- We get an answer by taking the normal form of the corresponding monomial. 
       	genvars := first entries vars amb;
	mono := product for i from 0 to (length v)-1 list(
	    (genvars#i)^(v#i)
	    );
	print("-- v:");
	print(toString(loopNum)|":"|toString(v));
    	print(g);
	g = pres#"InclusionBase"(g);
	print(g);
	diffPoly := g * (mono//subR);
	diffPoly = (pres#"ProjectionBase")(diffPoly);
	diffPoly = coefficient(leadMonomial tb, tb)*diffPoly;
	assert(leadTerm diffPoly == tb);
	result = result - diffPoly;
	loopNum = loopNum + 1;
    	);
    result
    );

-- This is subroutine 11.17 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    1
    );
-- This is subroutine 11.18 of Sturmfels.
   -- subR is a subring.
   -- S is a 1-row matrix with entries that are polynomials in the generators of subR.
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    
    amb := ambient subR;

    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    A := leadTerm gens subR;
    T := leadTerm S;
    T = apply(first entries T, m -> first exponents m);
    
    genVars := first entries vars amb;
    
    error "break";
    U := for i from 0 to (length T) - 1 list(
	v := T#i;
       	mono := product for i from 0 to (length v)-1 list((genVars#i)^(v#i));
	mono
	--mono // subR
	);

    error "break";
    );



