
export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "isSubalg"
    }

-- This function allows you to compute the lead term with respect to the ordering
-- on the upper variables induced from the ordering on the variables of the ambient
-- ring.
   -- subR is any Subring instance.
   -- f is an element of subR's tensor ring.
leadTerm(Subring, RingElement) := (subR, f) -> (
    fullSub := subR#"PresRing"#"FullSub";
    monos := monomials f;
    polys := fullSub monos;
    maxMono := max first entries polys;
    maxIndex := position(first entries polys, p -> p == maxMono);
    leadMono := monos_(0, maxIndex);
    coefficient(leadMono, f)*leadMono
    );
leadTerm(Subring, List) := (subR, L) -> (
    for i from 0 to (length L)-1 list(
	if L#i == 0 then (
	    0
	    ) else(
	    leadTerm(subR, L#i)
	    )
	)
    );
-- This is a bit different than the implementation of leadTerm(Matrix).
-- leadTerm(Matrix) only operates on the first nonzero entry of every column and sets
-- the entries below to zero. This operates on every single entry.  
leadTerm(Subring, Matrix) := (subR, M) -> (
    matrix (apply(entries M, row -> leadTerm(subR, row)))
    );


isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));

-- converts exponent vector L to a monomial in vars R.
toMonomial = (R, L) ->(
    variableList := flatten entries vars R;
    m := 1;
    for i from 0 to (#L-1) do(
	m = m*(variableList_i)^(L#i);
	);
    m	  
    );
-- returns the coefficient of the lead monomial of RingElement f.
leadCoef = f ->(
    coefficient(leadMonomial f, f)
    );



-- This is subroutine 11.14 of Sturmfels.
-- There are many simillarities between this calculation and the subduction algorithm.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- p is an element of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    if projInc G != G then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    
    -- This is one way to guarentee that p is actually an element of subR,
    -- but it requires p to be put into normal form beforehand which is an
    -- expensive operation. 
    -- TODO: Look into what happens when p isn't an element of subR.
    if projInc p != p then(
	--error "p must be a polynomial in the generators of subR."
	);
    
    amb := ambient subR;

    fullSub := pres#"FullSub";
    result := fullSub p;


    KA := subring(leadTerm gens subR);
    ringG := subring(fullSub G);
    inG := subring( (leadTerm fullSub G) );    
    loopNum := 0;
    
    Q := (gens inG)//KA;
    -- This is an ideal inside of the tensor ring of KA.
    I := monomialIdeal(Q);
    	
    while true do (
	--print("loopNum:"|toString(loopNum));	
	
	badTerms := result // KA;
      	badTerms = badTerms-(badTerms%I);
	badTerms = selectInSubring(1, monomials badTerms);
	
       	if badTerms == 0 then(
	    break;
	    );
	fullSub = KA#"PresRing"#"FullSub";
	subMap := KA#"PresRing"#"Substitution";

	tb := fullSub max first entries badTerms;	
	coef := coefficient(tb, result);
	assert(coef != 0);
	-- find a generator of inG that divides tb.
	pos := position(first entries gens inG, gen -> gcd(tb,gen) == gen);
	assert(pos =!= null);
	g := (gens inG)_(0, pos);
	v := (first exponents tb)-(first exponents g);

	-- mono is supposed to be an element of subR.
	mono := toMonomial(amb,v);
	mono = pres#"FullSub"(sub(mono//KA,pres#"TensorRing"));
	
	-- g is supposed to be an element of the intrinsic ideal.
	g = sub(g//inG, ringG#"PresRing"#"TensorRing");
	g = (ringG#"PresRing"#"FullSub")(g);	
	
	diffPoly := (g*mono)*coef;
		
	if(diffPoly == 0) then(
	    error "stop";
	    );
	assert( (leadTerm diffPoly) == tb*coef);
	
	result = result - diffPoly;	
	loopNum = loopNum + 1;
    	);
    assert(result%subR == 0);  
    result
    );

-- applies intrinsicReduce to each entry of the 1-row matrix M.
intrinsicReduce(Subring, Matrix, Matrix) := (subR, G, M) -> (
    matrix({apply(first entries M, ent -> intrinsicReduce(subR, G, ent))})
    );


-- This is subroutine 11.17 of Sturmfels.
-- NOTE: intrinsicBuchberger calls both intrinsicReduce and toricSyz. If intrinsicBuchberger is
-- tested extensively, toricSyz and intrinsicReduce can be safely assumed to be correct.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    amb := ambient subR;
    
    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    
    encountered := set(first entries S);
    currentGens := S;
    KA := subring leadTerm gens subR;

    loopNum := 0;
    while true do(
	print("---------------------------------");
	print("-- loop number "|toString(loopNum)|":");
	
    	C := leadTerm(fullSub currentGens);
	M := toricSyz(subR, C);
	print("Total syzygies: "|toString(numrows M));	
    	newGens := for i from 0 to (numrows M) - 1 list(
	    H := (M^{i} // subR);
	    
	    -- These assertions are condition 4.1. (Note: matrix equality is broken)
	    A := M^{i};
	    B := leadTerm fullSub H;
	    assert( H % subR == 0); -- H is an element of SubR^r.
	    assert( A - B == 0);

    	    f := sum(for j from 0 to (numcols currentGens)-1 list(H_(0,j)*(currentGens_(0,j)))); 
	    
	    --assert(f%subR == 0); 
	    hbar := intrinsicReduce(subR, S, f);
	    --assert(hbar%subR == 0);
	    
	    
	    if hbar == 0 then(
		print("zero");
	    	continue;
		);
	    hbar = hbar * (1/(leadCoef hbar));
	    if member(hbar, encountered) then(
		print("not new...");
		);
	    print("New - (#terms:"|toString(numcols monomials hbar)|" degree:"|toString(degree hbar)|")");
	    encountered = encountered + set({hbar});
	    hbar
	    );
	print("-- total new generators:"|toString(length newGens));
			
    	if newGens == {} then (
	    print("-- No new gens found.");
    	    break;	
	    )else(
	    newGens = subR#"PresRing"#"InclusionBase"(matrix({newGens}));
	    currentGens = currentGens | newGens;
	    );
    	loopNum = loopNum + 1;
        );
    print("-- Computing normal form of generators...");    
    currentGens = currentGens // subR;        
    print("-- Computing autoreduction...");
    reduced := for i from 0 to (numcols currentGens)-1 list(
	if (i % 10) == 0 then(
	    print(toString(i)|"/"|toString(numcols currentGens - 1));
	    );
	s := currentGens_(0,i);
	intrinsicReduce(subR, submatrix'(currentGens,,{i}), s)
	);
    matrix({reduced})
    );

-- This is subroutine 11.18 of Sturmfels.
-- Assumes M is a matrix of monomials in the toric ring K[A]
-- (for now,  it can be anything in the tensor ring of subR satisfying this condition,
-- involving the generators or the variables.)
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, M) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    incBase := pres#"InclusionBase";
    
    amb := ambient subR;
    r := numcols M;
    
    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if ring M === amb then(
	M = (pres#"InclusionBase")(M);
	) else if ring M =!= tense then(
	error "The entries of M must be in either the TensorRing or ambient ring of A.";
	);
    KA := subring leadTerm gens subR;
    M = sub(M, KA#"PresRing"#"TensorRing");    
    M = (KA#"PresRing"#"Substitution")(M);
    if leadTerm M != M then(
	error "Expected a 1-row matrix of monomials."; 
	); 
    
    U := M // KA;
    -- If some entry of M is not an element of KA, its normal form is zero.
    -- This will cause the assertion to fail.
    assert(KA#"PresRing"#"Substitution"(U) == M);

    -- each column of syzU is a relation of U.
    syzU := syz U;
    special := transpose syzU;
    
    -- U is supposed to in the upper variables only. 
    assert(KA#"PresRing"#"ProjectionInclusion" U == U);
    intersection := selectInSubring(1, gens gb intersect(ideal U, KA#"PresRing"#"LiftedPres"));    
    
    ---------------------------- The rest of this function is a hack. Is there a better solution? ------------------------------------
    
    -- In terms of the Sturmfels description, subRU is such that the upper variables of subRU are the e_i.
    -- We want to extract the coefficients of each e_i. The problem is that these upper variables are not
    -- inside of the coefficient ring, hence cannot be extracted with the function "coefficient."
    subRU := subring U;
    presRU := subRU#"PresRing";
    tenseU := presRU#"TensorRing";
    subU := presRU#"Substitution";

    -- It would be correct to run the following two lines, but also highly inefficient.
    --I := presRU#"SyzygyIdeal";
    --inter := (presRU#"InclusionBase")(intersection)%I;

    -- Since we know extra information about the elements of gens subRU (i.e., that they're all monomials)
    -- we can safely undo the substitution term by term. 
    
    U = presRU#"InclusionBase"(U);
    intersection = (presRU#"InclusionBase")(intersection);
    upperSubRU := first entries selectInSubring(1, vars tenseU);
    inter := for i from 0 to (numcols intersection)-1 list(
	elt := intersection_(0,i);
	--print("--------------------------"|toString(i)|"------------------------------");
	--cheat := elt%I;
	--print("Given element:"|toString(elt));
	--print("Probable answer:"|toString(cheat));	
	result := sum apply(terms elt, term -> (
		--print("----------------------------");
		--print("term: "|toString(term));
		
		-- (gcd discards the coefficient)
		pos := positions(upperSubRU, gen -> gcd(subU gen, term)*leadCoef(subU gen) == subU gen);	
		assert(pos =!= {});
    		
		-- if multiple monomials from U divide term, pick the lead term among them. 
		divisors := apply(first entries U_pos, m -> leadMonomial m);
		leadDivisor := leadMonomial (sum divisors);
		pos = pos#(position(divisors, d -> d == leadCoef(d)*leadDivisor));
		
		e := upperSubRU#pos;
		--print("has factor: "|toString(e)|"="|toString(leadDivisor));
		-- It intentionally doesn't use the full multiplicity of the generator.
		mono := first ((exponents term) - (exponents leadDivisor));
		mono = apply(mono, mult -> if mult > 0 then mult else 0);
		mono = toMonomial(tenseU, mono);
		mono = mono*(upperSubRU#pos);
		mono = mono * ((leadCoef term) / (leadCoef subU e));
		--print("final monomial: "|toString(mono));

		mono
		));
	--print("----------------------------");
	--print("Result:"|toString(result));
	--print("----------------------------");
	assert(subU result == subU elt);
	--assert(subU cheat == subU elt);
	--assert((presRU#"FullSub")(result) == (presRU#"FullSub")(cheat));
	result
	);
    inter = matrix({inter});
    magicRing := (KA#"PresRing"#"TensorRing")[upperSubRU];
    upperSubRU = gens magicRing; 
    --print("-- num syzygies:"|toString(numcols inter));
    ans := for i from 0 to (numcols inter)-1 list(
	subbed := sub(inter_(0,i), magicRing);
    	result := apply(upperSubRU, x -> coefficient(x, subbed));
	if select(result, x -> x != 0) == {} then(
	    error "Impossible";
	    );
	result
	);
    ans = (matrix ans) || special;
    
    tenseKA := KA#"PresRing"#"TensorRing";
    fullSubKA := KA#"PresRing"#"FullSub";
    ans = sub(ans, tenseKA);
    ans = transpose compress transpose ans;
    assert(fullSubKA(ans * (transpose M))== 0);

    ans = transpose compress transpose fullSubKA(ans);
    -- Discard the degree information because it breaks the matrix equality operator...
    -- Not really sure what the degrees of a matrix (the numbers in the brackets) are for.
    matrix entries ans
    );



