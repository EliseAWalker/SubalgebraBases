
export {
    "intrinsicReduce",
    "intrinsicBuchberger"
    }

-- This is subroutine 11.14 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- f is an element of subR. Hence, it is a polynomial in the upper variables of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    if projInc G != G then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    if projInc p != p then(
	error "p must be a polynomial in the generators of subR."
	);

    -- The ordering inside K[F] should be induced by the ordering on the ambient ring.
    -- The tensor ring has a GrevLex on the variables corresponding to generators.
    -- Make sure to use the induced order, not the GRevLex order. 
    fullSub := pres#"FullSub";
    inG := leadTerm fullSub G;
    result := fullSub p;
    amb := ambient subR;
    
    loopNum := 0;
    while true do (
	-- find a term tb of p that lies in the ideal in(G), halt if there is none.
    	badTerms := result - (result % ideal(inG));
	if badTerms == 0_amb then(
	    break;
	    );
	-- we can operate on any one of the monomials of badTerms. Arbitrarily use the lead term.
	tb := leadTerm badTerms;
	
	--loopNum = loopNum + 1;
	--print(toString(loopNum)|":"|toString(first exponents tb));
	
	-- find an element g of G such that tb lies in <in_w(G)>
	g := 0_amb;
	for i from 0 to (numcols inG) - 1 do(
	    elt := inG_(0,i);
	    if gcd(elt, tb) == elt then (
		g = elt;
		break;
		); 
	    );
        if g == 0_amb then(
	    error "Unknown failure (gens subR is not a Sagbi basis?)";
	    ); 	
       	v := first ((exponents tb) - (exponents g));
	
	-- Find an element of subR whose lead term has exponent vector v.
	-- This is equivalent to solving a certain integer program, and it can be done by computing a GB.
	-- In the notation of Kreuzer and Robbiano tutorial 36, v is the exponent vector of sum{y_{i}^{b_i}}.
	-- We get an answer by taking the normal form of the corresponding monomial. 
       	genvars := first entries vars amb;
	mono := product for i from 0 to (length v)-1 list(
	    (genvars#i)^(v#i)
	    );
	diffPoly := g * (mono//subR);
	diffPoly = coefficient(leadMonomial tb, tb)*diffPoly;
	assert(leadTerm diffPoly == tb);
	result = result - diffPoly;
    	);
    result
    );

-- This is subroutine 11.17 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    );
