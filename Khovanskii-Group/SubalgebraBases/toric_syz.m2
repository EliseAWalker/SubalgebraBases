
export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "isSubalg"
    }

isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));




-- This is subroutine 11.14 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- f is an element of subR. Hence, it is a polynomial in the upper variables of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    if projInc G != G then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    if projInc p != p then(
	error "p must be a polynomial in the generators of subR."
	);
    
    -- The ordering inside K[F] should be induced by the ordering on the ambient ring.
    -- The tensor ring has a GrevLex on the variables corresponding to generators.
    -- Make sure to use the induced order, not the GRevLex order.
    fullSub := pres#"FullSub";
    result := fullSub p;
    amb := ambient subR;
    
    -*
    print("-- Exponent vectors of the lead terms of gens subR::");
    for i from 0 to (numgens subR) - 1 do(
	print(toString(i)|":"|toString(first exponents (first entries leadTerm gens subR)#i));	
	);
    print("--------------------------------------------");
    *-
     
    -- We have to construct the initial ideal as a subalgebra because we will need to test membership.
    -- The initial ideal of an ideal inside of a subalgebra is not contained in the subalgebra itself.
    -- As Sturmfels mentions, it is instead contained in K[A].
    KA := subring(leadTerm gens subR);
    inG := subring(leadTerm fullSub G);
    --assert(isSubalg(inG, KA));    
    loopNum := 0;
    while true do (
	-- find a term tb of result that lies in the ideal in(G), halt if there is none.	
	
        -- Computing the normal form like this is far too slow...
	-- Internally, it's calculating a huge GB. Is this really neccessary? 
	
    	--(inG#"PresRing"#"InclusionBase")(result) % (inG#"PresRing"#"SyzygyIdeal")
    	map1 := inG#"PresRing"#"InclusionBase";
	map2 := inG#"PresRing"#"ProjectionBase";
    	map3 := (inG#"PresRing"#"FullSub");
	badTerms := result - map3(map1(result)%(inG#"PresRing"#"SyzygyIdeal"));
	
	if badTerms == 0_amb then(
	    break;
	    );
	-- we can operate on any one of the monomials of badTerms. Arbitrarily use the lead term.
	tb := leadTerm badTerms;
	--print("-- Term to eliminate:");
	--print(toString(loopNum)|":"|toString(first exponents tb));
	
	-- find an element g of G such that tb lies in <in_w(G)>
	g := 0_amb;
	for i from 0 to (numcols gens inG) - 1 do(
	    elt := (gens inG)_(0,i);
	    if gcd(elt, tb) == elt then (
		g = elt;
		break;
		); 
	    );
        if g == 0_amb then(
	    error "Unknown failure (gens subR is not a Sagbi basis?)";
	    ); 	
	--print("-- eliminating term tb="|toString(tb));
	--print("-- found generator g="|toString(g)|" that divides tb.");
       	v := first ((exponents tb) - (exponents g));
	
	-- Find an element of subR whose lead term has exponent vector v.
	-- This is equivalent to solving a certain integer program, and it can be done by computing a GB.
	-- In the notation of Kreuzer and Robbiano tutorial 36, v is the exponent vector of sum{y_{i}^{b_i}}.
	-- We get an answer by taking the normal form of the corresponding monomial. 
       	genvars := first entries vars amb;
	mono := product for i from 0 to (length v)-1 list(
	    (genvars#i)^(v#i)
	    );
	--print("-- v:");
	--print(toString(loopNum)|":"|toString(v));
	g = pres#"InclusionBase"(g);
	diffPoly := g * (mono//subR);
	diffPoly = pres#"Substitution"(diffPoly);
	diffPoly = coefficient(leadMonomial tb, tb)*diffPoly;
	diffPoly = pres#"ProjectionBase"(diffPoly);
	assert(leadTerm diffPoly == tb);
	result = result - diffPoly;
	loopNum = loopNum + 1;
    	);
    result
    );

-- applies intrinsicReduce to each entry of the 1-row matrix M.
intrinsicReduce(Subring, Matrix, Matrix) := (subR, G, M) -> (
    matrix({apply(first entries M, ent -> intrinsicReduce(subR, G, ent))})
    );


-- This is subroutine 11.17 of Sturmfels.
-- NOTE: intrinsicBuchberger calls both intrinsicReduce and toricSyz. If intrinsicBuchberger is
-- tested extensively, toricSyz and intrinsicReduce can be safely assumed to be correct.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    amb := ambient subR;
    
    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    
    encountered := set(first entries S);
    currentGens := S;
    
    loopNum := 0;
    while true do(
	print("---------------------------------");
	print("-- loop number "|toString(loopNum)|":");
    	--C := apply(toList(currentGens), gen -> (leadTerm gen)//subR);
    	C := (leadTerm currentGens) // subR;
	
	
	print("-- computing toric syzygies...");
	M := transpose toricSyz(subR, C);
	print("-- computing normal forms... ("|toString(numcols M)|" total)");
    	newGens := for i from 0 to (numcols M) - 1 list(
	    error "stop";
	    colM := compress matrix {entries M_i};
	    H := colM // subR;
	    assert(leadTerm fullSub H == colM);
	    f := trace ((diagonalMatrix H)*(diagonalMatrix S));
	    intrinsicReduce(subR, S, f)
	    );
	print("-- removing duplicates...");
	
      	-- Multiply the polynomials newGens by constants to make them monic.
	newGens = for i from 0 to (length newGens)-1 list(
	    (newGens#i)*(1/(leadCoef(newGens#i)))
	    );
	for i from 0 to (length newGens)-1 do(
	    assert(leadCoef (newGens#i) == 1);
	    );
    	newGens = compress newGens;
	newGens = newGens // subR;
	nextGens := currentGens + set(first entries (newGens//subR));
	print("-- total generators:"|toString(#currentGens));
			
    	if #currentGens == #nextGens then (
	    print("-- No new gens found.");
    	    break;	
	    )else(
	    currentGens = nextGens;
	    );
    	loopNum = loopNum + 1;
        );
    
    print("-- Computing autoreduction...");
    currentGens = matrix {toList currentGens};
    
    return currentGens;
    
    
    
    reduced := for i from 0 to (numcols currentGens)-1 list(
	if (i % 10) == 0 then(
	    print(toString(i)|"/"|toString(numcols currentGens - 1));
	    );
    
	s := currentGens_(0,i);
	intrinsicReduce(subR, submatrix'(currentGens,,{i}), s)
	);
    matrix({reduced})
    );


-- converts exponent vector L to a monomial in vars R.
toMonomial = (R, L) ->(
    variableList := flatten entries vars R;
    m := 1;
    for i from 0 to (#L-1) do(
	m = m*(variableList_i)^(L#i);
	);
    m	  
    );
-- returns the coefficient of the lead monomial of RingElement f.
leadCoef = f ->(
    coefficient(leadMonomial f, f)
    );


-- This is subroutine 11.18 of Sturmfels.
   -- subR is a subring whose initial algebra contains the entries of M.
   -- M is a 1-row matrix with entries in subR.
   -- (We only use the leadTerms of S. S is supposed to be a vector of monomials.)
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, M) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    incBase := pres#"InclusionBase";
    
    amb := ambient subR;
    r := numcols M;
    
    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if projInc M != M then(
	error "M must contain entries that are polynomials in the generators of subR."
	);
    KA := subring leadTerm gens subR;

    -- It calls fullSub first because the ordering of the upper variables is arbitrary. 
    -- Remember, M does not contain elements of subR. Instead, its entries are from KA.
    T := leadTerm (fullSub M);
        
    genVars := first entries vars amb;
    -- For each i, find an element U#i of subR whose lead term is T#i. 
    U := for i from 0 to (numcols T) - 1 list(
	ans := leadTerm (T_(0,i) // subR);
	assert(leadTerm fullSub(ans) == T_(0,i)); 
    	ans
	);
    U = matrix({U});
    
    -- each column of syzU is a relation of U.
    syzU := syz U;

    special := transpose syzU;
    
    -- U is supposed to in the upper variables only. 
    assert(projInc U == U);
    
    intersection := selectInSubring(1, gens gb intersect(ideal U, pres#"SyzygyIdeal"));
        
    --intersection := (gens gb intersect(ideal U, pres#"SyzygyIdeal"))//subR;
    --intersection = compress intersection;
    -- U is a 1-row matrix over tenseSagbi. 
    
    
    -- In terms of the Sturmfels description, subRU is such that the upper variables of subRU are the e_i.
    -- We want to extract the coefficients of each e_i. The problem is that these upper variables are not
    -- inside of the coefficient ring, hence cannot be extracted with the function "coefficient."
    subRU := subring U;
    presRU := subRU#"PresRing";
    tenseU := presRU#"TensorRing";
    subU := presRU#"Substitution";

    -- It would be correct to run the following two lines, but also highly inefficient.
    I := presRU#"SyzygyIdeal";
    --inter := (presRU#"InclusionBase")(intersection)%I;

    -- Since we know extra information about the elements of gens subRU (i.e., that they're all monomials)
    -- we can safely undo the substitution term by term. 

    
    U = presRU#"InclusionBase"(U);
    intersection = (presRU#"InclusionBase")(intersection);
    upperSubRU := first entries selectInSubring(1, vars tenseU);
    inter := for i from 0 to (numcols intersection)-1 list(
	elt := intersection_(0,i);
	--print("--------------------------"|toString(i)|"------------------------------");
	--cheat := elt%I;
	--print("Given element:"|toString(elt));
	--print("Probable answer:"|toString(cheat));	
	result := sum apply(terms elt, term -> (
		--print("----------------------------");
		--print("term: "|toString(term));
		
		-- (gcd discards the coefficient)
		pos := positions(upperSubRU, gen -> gcd(subU gen, term)*leadCoef(subU gen) == subU gen);	
		assert(pos =!= {});
    		
		-- if multiple monomials from U divide term, pick the lead term among them. 
		divisors := apply(first entries U_pos, m -> leadMonomial m);
		leadDivisor := leadMonomial (sum divisors);
		pos = pos#(position(divisors, d -> d == leadCoef(d)*leadDivisor));
		
		e := upperSubRU#pos;
		--print("has factor: "|toString(e)|"="|toString(leadDivisor));
		-- It intentionally doesn't use the full multiplicity of the generator.
		mono := first ((exponents term) - (exponents leadDivisor));
		mono = apply(mono, mult -> if mult > 0 then mult else 0);
		mono = toMonomial(tenseU, mono);
		mono = mono*(upperSubRU#pos);
		mono = mono * ((leadCoef term) / (leadCoef subU e));
		--print("final monomial: "|toString(mono));

		mono
		));
	--print("----------------------------");
	--print("Result:"|toString(result));
	--print("----------------------------");
	assert(subU result == subU elt);
	--assert(subU cheat == subU elt);
	--assert((presRU#"FullSub")(result) == (presRU#"FullSub")(cheat));
	result
	);
    inter = matrix({inter});
    --error "stop";
    magicRing := tense[upperSubRU];
    upperSubRU = gens magicRing; 
    --print("-- num syzygies:"|toString(numcols inter));
    ans := for i from 0 to (numcols inter)-1 list(
	subbed := sub(inter_(0,i), magicRing);
    	result := apply(upperSubRU, x -> coefficient(x, subbed));
	if select(result, x -> x != 0) == {} then(
	    error "Impossible";
	    );
	result
	);
    ans = (matrix ans) || special;
    
    -- At this point, ans is an (n x r) matrix whose entries are polynomials in the gens of subR. 
    -- Given the construction of KA, we can also consider the entries to be polynomials in the gens of KA.

    tenseKA := KA#"PresRing"#"TensorRing";
    fullSubKA := KA#"PresRing"#"FullSub";

    ans = fullSubKA sub(ans, tenseKA);
    ans = transpose compress transpose ans;
    assert(ans * (transpose T) == 0);
    -- The reason we have to reconstruct the matrix before we return it is to discard the "degrees."
    -- These aren't documented (as far as I'm aware) and they break the == operator...
    matrix entries ans
    );



