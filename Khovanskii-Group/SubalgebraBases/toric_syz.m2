export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "genVars",
    "isSubalg",
    "autoreduce",
    "monoCoef",
    "toMonomial"
    }

-- Returns the variables corresponding to the subalgebra generators in the 
-- tensor ring of a subring instance,
    -- subR is any Subring instance.
genVars = method(TypicalValue => Matrix)
genVars(Subring) := subR ->(
    selectInSubring(1, vars subR#"PresRing"#"TensorRing")    
    );

-- This function allows you to compute the lead term with respect to the ordering
-- on the upper variables induced from the ordering on the variables of the ambient
-- ring.
   -- subR is any Subring instance.
   -- f is an element of subR's tensor ring.
leadTerm(Subring, RingElement) := (subR, f) -> (
    fullSub := subR#"PresRing"#"FullSub";
    monos := monomials f;
    polys := fullSub monos;
    maxMono := max first entries polys;
    maxIndex := position(first entries polys, p -> p == maxMono);
    leadMono := monos_(0, maxIndex);
    coefficient(leadMono, f)*leadMono
    );
leadTerm(Subring, List) := (subR, L) -> (
    for i from 0 to (length L)-1 list(
	if L#i == 0 then (
	    0
	    ) else(
	    leadTerm(subR, L#i)
	    )
	)
    );

-- This is a bit different than the implementation of leadTerm(Matrix).
-- leadTerm(Matrix) only operates on the first nonzero entry of every column and sets
-- the entries below to zero. This operates on every single entry.  
leadTerm(Subring, Matrix) := (subR, M) -> (
    matrix (apply(entries M, row -> leadTerm(subR, row)))
    );

isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));

-- converts exponent vector L to a monomial in vars R.
toMonomial = (R, L) ->(
    variableList := flatten entries vars R;
    m := 1;
    for i from 0 to (length L)-1 do(
	m = m*(variableList_i)^(L#i);
	);
    m	  
    );

-- returns the coefficient of the lead monomial of RingElement f.
leadCoef = f ->(
    coefficient(leadMonomial f, f)
    );

-- This is subroutine 11.14 of Sturmfels.
-- There are many simillarities between this calculation and the subduction algorithm.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- p is an element of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    
    -- This is one way to guarentee that p is actually an element of subR,
    -- but it requires p to be put into normal form beforehand which is an
    -- expensive operation. 
    -- TODO: Look into what happens when p isn't an element of subR.
    --if projInc p != p then(
	--error "p must be a polynomial in the generators of subR."
	--);
    --if projInc G != G then(
        --error "G must contain entries that are polynomials in the generators of subR."
        --);
    
    amb := ambient subR;
    fullSub := pres#"FullSub";
    
    result := p;
    
    -- If the  === comparison is true, it  does not guarentee that will not throw an error.
    
    if source fullSub === ring p then(
    	result = fullSub p;
    	);
    
    if source fullSub === ring G then(
    	G = fullSub G;
    	);
   
    
    KA := subring(leadTerm gens subR);
    ringG := subring(G);
    inG := subring (leadTerm G);    
    
    Q := (gens inG)//KA;
    -- This is an ideal inside of the _tensor ring_ of KA.
    I := monomialIdeal(Q);

    loopNum := 0;    	
    while true do (
	if(loopNum % 10 == 0) then(
	    print("reduction step:"|toString(loopNum));
	    );
	badTerms := result // KA;
	badTerms = badTerms-(badTerms%I);
	badTerms = selectInSubring(1, monomials badTerms);
	
       	if badTerms == 0 then(
	    break;
	    );
	fullSub = KA#"PresRing"#"FullSub";
	subMap := KA#"PresRing"#"Substitution";

	tb := fullSub max first entries badTerms;	
	assert(coefficient(tb, result) != 0);
	
	--pos := position(first entries gens inG, gen -> gcd(tb,gen) == leadMonomial gen);
	
	-- find a generator of inG that "divides" tb.
	-- (Note: it isn't enough to have gcd(tb, gen) == gen.)
	pos := position(first entries Q, gen -> (tb//KA)%(monomialIdeal gen) == 0);
	assert(pos =!= null);
	g := fullSub(Q_(0,pos));
	v := first ((exponents tb)-(exponents g));
	
	-- mono is supposed to be an element of subR.
	mono := toMonomial(amb,v)//subR;
	mono = pres#"FullSub"(mono);
	assert(mono%subR == 0);

	-- g is supposed to be an element of the intrinsic ideal.
	g = sub(g//inG, ringG#"PresRing"#"TensorRing");
	g = (ringG#"PresRing"#"FullSub")(g);	
	
	
	-- since an ideal absorbs outside products, we know that diffPoly is an element of the ideal G.
	diffPoly := g*mono;
	
	if(diffPoly == 0) then(
	    error "This is not supposed to happen. (bug within the function intrinsicReduce.)";
	    );
	
	coef := coefficient(tb, diffPoly);
	assert( (leadTerm diffPoly) == tb*coef);
	
	result = result - diffPoly;
	
	if(loopNum > 500) then(
	    error "stop";
	    );
	
		
	loopNum = loopNum + 1;
    	);
    assert(result%subR == 0);  
    result
    );

-- applies intrinsicReduce to each entry of the 1-row matrix M.
intrinsicReduce(Subring, Matrix, Matrix) := (subR, G, M) -> (
    matrix({apply(first entries M, ent -> intrinsicReduce(subR, G, ent))})
    );


-- This is subroutine 11.17 of Sturmfels.
-- NOTE: intrinsicBuchberger calls both intrinsicReduce and toricSyz. If intrinsicBuchberger is
-- tested extensively, toricSyz and intrinsicReduce can be safely assumed to be correct.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    amb := ambient subR;
    
    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    
    encountered := set(first entries S);
    currentGens := S;
    KA := subring leadTerm gens subR;

    loopNum := 0;
    while true do(
	print("---------------------------------");
	print("-- loop number "|toString(loopNum)|":");
	
    	C := leadTerm(fullSub currentGens);
	M := toricSyz(subR, C);
	print("Total syzygies: "|toString(numrows M));	
    	newGens := for i from 0 to (numrows M) - 1 list(
	    H := (M^{i} // subR);
	    
	    -- These assertions are condition 4.1.
	    A := M^{i};
	    B := leadTerm fullSub H;
	    assert( H % subR == 0); -- H is an element of SubR^r.
	    assert( A - B == 0);

    	    f := sum(for j from 0 to (numcols currentGens)-1 list(H_(0,j)*(currentGens_(0,j)))); 
	    
	    --assert(f%subR == 0); 
	    hbar := intrinsicReduce(subR, S, f);
	    --assert(hbar%subR == 0);
	    
	    
	    if hbar == 0 then(
		print("zero");
	    	continue;
		);
	    hbar = hbar * (1/(leadCoef hbar));
	    if member(hbar, encountered) then(
		print("not new...");
		);
	    print("New - (#terms:"|toString(numcols monomials hbar)|" degree:"|toString(degree hbar)|")");
	    encountered = encountered + set({hbar});
	    hbar
	    );
	print("-- total new generators:"|toString(length newGens));
			
    	if newGens == {} then (
	    print("-- No new gens found.");
    	    break;	
	    )else(
	    newGens = subR#"PresRing"#"InclusionBase"(matrix({newGens}));
	    currentGens = currentGens | newGens;
	    );
    	loopNum = loopNum + 1;
        );
    print("-- Computing normal form of generators...");    
    currentGens = currentGens // subR;        
    print("-- Computing autoreduction...");
    reduced := for i from 0 to (numcols currentGens)-1 list(
	if (i % 10) == 0 then(
	    print(toString(i)|"/"|toString(numcols currentGens - 1));
	    );
	s := currentGens_(0,i);
	intrinsicReduce(subR, submatrix'(currentGens,,{i}), s)
	);
    matrix({reduced})
    );

-- For polynomial p monomial m, extract the coefficient of m in p. For example:
-- p = x*y*z + z*y^2 + 2x^2*y^2*z^2
-- m = x*y
-- Then:
-- p = (z+2x*y*z^2)*m + z*y^2 
-- monoCoef(p, m) = z+2x*y*z^2.
-- (Notice that the coefficient of the monomial m may involve m.)
-- (Also, if m has a coefficient other than one it will be ignored.)
monoCoef = method(TypicalValue => RingElement)
monoCoef(RingElement, RingElement) := (m, p) -> (
    
    -- This does not completley guarentee that they are elements of the same ring... 
    if ring m =!= ring p then (
	error "monoCoef expected m and p to be elements of the same ring.";
	);
    supp := support(m);
    R := ring(m);
    if numcols monomials m != 1 or supp == {} then(
	error "monoCoef expects m to be a non-constant monomial.";
	);
    -- remove the coefficient of m.
    m = toMonomial(ring m, first exponents m);

    monosP := monomials p;
    coefs := for i from 0 to (numcols monosP)-1 list(
	mono := monosP_(0,i);
	if gcd(m, mono) == leadTerm m then(
	    (coefficient(mono, p))*toMonomial(R, first ((exponents mono)-(exponents m)))
	    ) else(
	    0
	    )
	);
    sum coefs   
    );


-- Perform autoreduction on the generators of an intrinsic ideal:
-- I.e., reduce g\in idealGens modulo idealGens-g for all g\in idealGens.   
   -- subR is a Subring (probably has to be a Sagbi basis)
   -- idealGens is a 1-row matrix containing generators of an ideal in subR.
autoreduce = method(TypicalValue => Matrix)
autoreduce(Subring, Matrix) := (subR, idealGens) -> (
    noDupes := new MutableList from first entries idealGens;        
    reducedGens := for i from 0 to (numcols idealGens)-1 list(	
	s := idealGens_(0,i);
	notS := submatrix'(matrix({toList noDupes}),,{i});      
	answer := intrinsicReduce(subR, notS, s);
       	answer = sub(answer,ring idealGens);
	noDupes#i = answer;
	-*
	print("--------------  i:"|toString(i)|" ---------------");
	print("reducing:    ");
	print(s);	
	print(s//subR);	
	print("in ring:     ");
	print(transpose gens subR);
	print("w.r.t. ideal:");
	print(transpose notS);
	print("result:  "|toString(answer));
	*-
	answer
	);
    -- The extra "matrix entries" is to eliminate the degrees (which are the numbers in curly brackets)
    -- I don't know what they are for and they break the == operator.
    matrix entries (transpose compress (matrix({reducedGens})))
    );




-- This is subroutine 11.18 of Sturmfels.
-- Assumes M is a matrix of monomials in the toric ring K[A]
-- (for now,  it can be anything in the tensor ring of subR satisfying this condition,
-- involving the generators or the variables.)
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, M) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    incBase := pres#"InclusionBase";
    
    amb := ambient subR;
    r := numcols M;
    
    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if ring M === amb then(
	M = (pres#"InclusionBase")(M);
	) else if ring M =!= tense then(
	error "The entries of M must be in either the TensorRing or ambient ring of A.";
	);
    KA := subring leadTerm gens subR;
    tenseKA := KA#"PresRing"#"TensorRing";
    M = sub(M, tenseKA);    
    M = (KA#"PresRing"#"Substitution")(M);
    if leadTerm M != M then(
	error "Expected a 1-row matrix of monomials."; 
	); 
    
    U := M // KA;
    -- If some entry of M is not an element of KA, its normal form is zero.
    -- This will cause the assertion to fail.
    assert(KA#"PresRing"#"Substitution"(U) == M);

    -- each column of syzU is a relation of U.
    syzU := syz U;
    special := transpose syzU;
    
    -- U is supposed to in the upper variables only. 
    assert(KA#"PresRing"#"ProjectionInclusion" U == U);
    intersection := selectInSubring(1, gens gb intersect(ideal U, KA#"PresRing"#"LiftedPres"));    
    
    binomials := for i from 0 to (numcols intersection)-1 list(
	ent := intersection_(0,i);
	coefs := apply(first entries U, e -> monoCoef(e, ent));
      	if position(coefs, c -> c != 0) === null then (
	    error "Error: something impossible happened. (This may be a bug in the function toricSyz.)";
	    );
    	coefs 
	);
    binomials = (matrix binomials) || special;
    fullSubKA := KA#"PresRing"#"FullSub";
    binomials = transpose compress transpose fullSubKA binomials;
    matrix entries binomials
    );
