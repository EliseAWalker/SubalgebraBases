
export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "isSubalg"
    }

isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));









-- This is subroutine 11.14 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- f is an element of subR. Hence, it is a polynomial in the upper variables of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    if projInc G != G then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    if projInc p != p then(
	error "p must be a polynomial in the generators of subR."
	);
    
    -- The ordering inside K[F] should be induced by the ordering on the ambient ring.
    -- The tensor ring has a GrevLex on the variables corresponding to generators.
    -- Make sure to use the induced order, not the GRevLex order.
    fullSub := pres#"FullSub";
    result := fullSub p;
    amb := ambient subR;
    
    -*
    print("-- Exponent vectors of the lead terms of gens subR::");
    for i from 0 to (numgens subR) - 1 do(
	print(toString(i)|":"|toString(first exponents (first entries leadTerm gens subR)#i));	
	);
    print("--------------------------------------------");
    *-
     
    -- We have to construct the initial ideal as a subalgebra because we will need to test membership.
    -- The initial ideal of an ideal inside of a subalgebra is not contained in the subalgebra itself.
    -- As Sturmfels mentions, it is instead contained in K[A].
    KA := subring(leadTerm gens subR);
    inG := subring(leadTerm fullSub G);
    
    -- This is temporary
    --assert(isSubalg(inG, KA));    
    
    loopNum := 0;
    while true do (
	-- find a term tb of result that lies in the ideal in(G), halt if there is none.	
    	badTerms := result - (inG#"PresRing"#"FullSub")(result % inG);
	
	if badTerms == 0_amb then(
	    break;
	    );
	-- we can operate on any one of the monomials of badTerms. Arbitrarily use the lead term.
	tb := leadTerm badTerms;
	--print("-- Term to eliminate:");
	--print(toString(loopNum)|":"|toString(first exponents tb));
	
	-- find an element g of G such that tb lies in <in_w(G)>
	g := 0_amb;
	for i from 0 to (numcols gens inG) - 1 do(
	    elt := (gens inG)_(0,i);
	    if gcd(elt, tb) == elt then (
		g = elt;
		break;
		); 
	    );
        if g == 0_amb then(
	    error "Unknown failure (gens subR is not a Sagbi basis?)";
	    ); 	
	
       	v := first ((exponents tb) - (exponents g));
	
	-- Find an element of subR whose lead term has exponent vector v.
	-- This is equivalent to solving a certain integer program, and it can be done by computing a GB.
	-- In the notation of Kreuzer and Robbiano tutorial 36, v is the exponent vector of sum{y_{i}^{b_i}}.
	-- We get an answer by taking the normal form of the corresponding monomial. 
       	genvars := first entries vars amb;
	mono := product for i from 0 to (length v)-1 list(
	    (genvars#i)^(v#i)
	    );
	--print("-- v:");
	--print(toString(loopNum)|":"|toString(v));
    	--print(g);
	g = pres#"InclusionBase"(g);
	--print(g);
	diffPoly := g * (mono//subR);
	diffPoly = (pres#"ProjectionBase")(diffPoly);
	diffPoly = coefficient(leadMonomial tb, tb)*diffPoly;
	assert(leadTerm diffPoly == tb);
	result = result - diffPoly;
	loopNum = loopNum + 1;
    	);
    result
    );

-- This is subroutine 11.17 of Sturmfels.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    1
    );




-- This is subroutine 11.18 of Sturmfels.
   -- subR is a subring whose initial algebra contains the entries of M.
   -- M is a 1-row matrix with entries in subR.
   -- (We only use the leadTerms of S. S is supposed to be a vector of monomials.)
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, M) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";

    amb := ambient subR;
    r := numcols M;
    
    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if projInc M != M then(
	error "M must contain entries that are polynomials in the generators of subR."
	);
    KA := subring leadTerm gens subR;

    -- It calls fullSub first because the ordering of the upper variables is arbitrary. 
    -- Remember, M does not contain elements of subR. Instead, its entries are from KA.
    T := leadTerm (fullSub M);
        
    genVars := first entries vars amb;
    -- For each i, find an element U#i of subR whose lead term is T#i. 
    U := for i from 0 to (numcols T) - 1 list(
	ans := T_(0,i) // subR;
	assert(leadTerm fullSub(ans) == T_(0,i)); 
    	ans
	);
    U = matrix({U});
    
    -- each column of syzU is a relation of U.
    syzU := syz U;

    -- Not sure why the algorithm "singles out" this syzygy.
    special := transpose syzU;
         
    -- pres#"SyzygyIdeal" is I_A.
    intersection := selectInSubring(1, gens gb intersect(ideal(U), pres#"SyzygyIdeal"));
    
    -- In terms of the Sturmfels description, subRU is such that the upper variables of subRU are the e_i.
    -- We want to extract the coefficients of each e_i. The problem is that these upper variables are not
    -- inside of the coefficient ring, hence cannot be extracted with the function coefficient.
    subRU := subring U;
    tenseU := subRU#"PresRing"#"TensorRing";    
    I := subRU#"PresRing"#"SyzygyIdeal";
    inter := sub(intersection, tenseU) % I;
    upperSubRU := first entries selectInSubring(1, vars tenseU);
    magicRing := tense[upperSubRU];
    upperSubRU = gens magicRing; 
    
    ans := for i from 0 to (numcols inter)-1 list(
	subbed := sub(inter_(0,i), magicRing);
	apply(upperSubRU, x -> coefficient(x, subbed))
	);
    
    ans = (matrix ans) || special;
    
    -- At this point, ans is an (n x r) matrix whose entries are polynomials in the gens of subR. 
    -- Given the construction of KA, we can also consider the entries to be polynomials in the gens of KA.
    tenseKA := KA#"PresRing"#"TensorRing";
    fullSubKA := KA#"PresRing"#"FullSub";
    ans = fullSubKA sub(ans, tenseKA);
    ans = transpose compress transpose ans;
    assert(ans * (transpose T) == 0);
    
    -- The answer is a subset of K[A]^r (an (r x n) matrix.)
    ans
    );



