export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "genVars",
    "isSubalg",
    "autoreduce",
    "monoCoef",
    "toMonomial",
    "moduleToSubring",
    "extractEntries",
    "mingensSubring",
    "debugPrintMap",
    "debugPrintAllMaps"
    }

debugPrintMap = method()
debugPrintMap(RingMap) := f -> (
    a := gens source f;
    for i from 0 to (length a)-1 do(
	elt := f(a_i);
	print("maps "|toString(a_i)|" to "|toString(elt));
	);    
    );


debugPrintAllMaps = method()
debugPrintAllMaps(Subring) := subR -> (
    pres := makePresRing(subR);
    print("--------------------------------");
    print("-- PresRing map info dump:");
    print("--------------------------------");
    print("-- ProjectionInclusion:");
    debugPrintMap (pres#"ProjectionInclusion");
    print("-- ProjectionBase:");
    debugPrintMap (pres#"ProjectionBase");
    print("-- InclusionBase:");
    debugPrintMap (pres#"InclusionBase");
    print("-- Substitution:");
    debugPrintMap (pres#"Substitution");
    print("-- FullSub:");
    debugPrintMap (pres#"FullSub");
    print("--------------------------------");
    print("-- End PresRing map info dump.");
    print("--------------------------------");
    );


-- Returns the variables corresponding to the subalgebra generators in the 
-- tensor ring of a subring instance,
    -- subR is any Subring instance.
genVars = method(TypicalValue => Matrix)
genVars(Subring) := subR ->(
    selectInSubring(1, vars subR#"PresRing"#"TensorRing")    
    );

-- Not sure if this function is practically useful or not. For now, it's worth
-- keeping for testing the monomial order on the tensor ring created by the
-- subring constructor.
-- Computes the lead term with respect to the ordering on the upper variables
-- induced from the ordering on the variables of the ambient ring.
   -- subR is any Subring instance.
   -- f is an element of subR's tensor ring.
leadTerm(Subring, RingElement) := (subR, f) -> (
    fullSub := subR#"PresRing"#"FullSub";
    monos := monomials f;
    polys := fullSub monos;
    maxMono := max first entries polys;
    maxIndex := position(first entries polys, p -> p == maxMono);
    leadMono := monos_(0, maxIndex);
    coefficient(leadMono, f)*leadMono
    );
leadTerm(Subring, List) := (subR, L) -> (
    for i from 0 to (length L)-1 list(
	if L#i == 0 then (
	    0
	    ) else(
	    leadTerm(subR, L#i)
	    )
	)
    );

-- This is a bit different than the implementation of leadTerm(Matrix).
-- leadTerm(Matrix) only operates on the first nonzero entry of every column and sets
-- the entries below to zero. This operates on every single entry.  
leadTerm(Subring, Matrix) := (subR, M) -> (
    matrix (apply(entries M, row -> leadTerm(subR, row)))
    );

isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));

-- converts exponent vector L to a monomial in vars R.
toMonomial = (R, L) ->(
    variableList := flatten entries vars R;
    m := 1;
    for i from 0 to (length L)-1 do(
	m = m*(variableList_i)^(L#i);
	);
    m	  
    );

-- returns the coefficient of the lead monomial of RingElement f.
leadCoef = f ->(
    coefficient(leadMonomial f, f)
    );

debugBreakFlag := false;

-- This is subroutine 11.14 of Sturmfels.
-- There are many simillarities between this calculation and the subduction algorithm.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- p is an element of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    
    -- This is one way to guarentee that p is actually an element of subR,
    -- but it requires p to be put into normal form beforehand which is an
    -- expensive operation. 
    -- TODO: Look into what happens when p isn't an element of subR.
    --if projInc p != p then(
	--error "p must be a polynomial in the generators of subR."
	--);
    --if projInc G != G then(
        --error "G must contain entries that are polynomials in the generators of subR."
        --);
    
    amb := ambient subR;
    fullSub := pres#"FullSub";
    result := p;
    
    -- If the  === comparison is true, it  does not guarentee that will not throw an error.
    if source fullSub === ring p then(
    	result = fullSub p;
    	);    
    if source fullSub === ring G then(
    	G = fullSub G;
    	);
   
    -- This call to sagbi will not take long.
    KA := sagbi subring(leadTerm gens subR);
    tenseKA := KA#"PresRing"#"TensorRing";
    Q := (leadTerm G)//KA;
    
    -- This is an ideal inside of the _tensor ring_ of KA.
    I := monomialIdeal(Q);

    loopNum := 0;    	
    while true do (
	if loopNum % 100 == 0 and loopNum > 0 then(
	    print("reduction step:"|toString(loopNum));
	    );	
	badTerms := result // KA;
	badTerms = badTerms-(badTerms%I);
	badTerms = selectInSubring(1, monomials badTerms);		
	
       	if badTerms == 0 then(
	    break;
	    );
	fullSubKA := KA#"PresRing"#"FullSub";
	subMap := KA#"PresRing"#"Substitution";

	tb := fullSubKA max first entries badTerms;	
	assert(coefficient(tb, result) != 0);
	
	pos := position(first entries Q, gen -> (tb//KA)%(monomialIdeal gen) == 0);
	assert(pos =!= null);
	
	g := fullSubKA (Q_(0,pos));
	v := first ((exponents tb)-(exponents g));
	
	-- mono is supposed to be an element of subR.
	mono := toMonomial(amb,v)//subR;
	mono = fullSub(mono);
	assert(mono%subR == 0);

	-- g is supposed to an element of the subring generated by G.
	g = G_(0,pos);	
	
	-- since an ideal absorbs outside products, we know that diffPoly is an element of ideal G.
	diffPoly := g*mono;
		
	if(diffPoly == 0) then(
	    error "This is not supposed to happen. (Possibly a bug within the function intrinsicReduce.)";
	    );
	
	coef := coefficient(tb, diffPoly);
	assert( (leadTerm diffPoly) == tb*coef);
	assert(coefficient(tb, result) != 0);
	diffPoly = diffPoly * (1/coefficient(tb, diffPoly));
	diffPoly = diffPoly * coefficient(tb, result);
        assert(coefficient(tb, diffPoly) == coefficient(tb, result));
	result = result - diffPoly;	
		
	loopNum = loopNum + 1;
    	);
    assert(result%subR == 0);  
    result
    );

-- applies intrinsicReduce to each entry of the 1-row matrix M.
intrinsicReduce(Subring, Matrix, Matrix) := (subR, G, M) -> (
    matrix({apply(first entries M, ent -> intrinsicReduce(subR, G, ent))})
    );


-- This is subroutine 11.17 of Sturmfels.
-- NOTE: intrinsicBuchberger calls both intrinsicReduce and toricSyz. If intrinsicBuchberger is
-- tested extensively, toricSyz and intrinsicReduce can be safely assumed to be correct.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    amb := ambient subR;
    
    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    
    encountered := set(first entries S);
    currentGens := S;
    
    KA := sagbi subring leadTerm gens subR;

    loopNum := 0;
    while true do(
	print("---------------------------------");
	print("-- loop number "|toString(loopNum)|":");
	
    	C := leadTerm(fullSub currentGens);
	print("finding toric syzygies...");
	M := toricSyz(subR, C);
	print("num. syzygies before autoreduction:"|toString(numrows M));	
	print("computing autoreduction...");
	if(loopNum == 1) then(
	    debugBreakFlag = true;
	    --error "break";
	    );
	
	
	--M = mingensSubring(KA, M);
	M = transpose compress KA#"PresRing"#"FullSub"(gens gb (transpose M//KA));	
	
	print("num. syzygies after reduction: "|toString(numrows M));	
    	newGens := for i from 0 to (numrows M) - 1 list(
	    H := (M^{i} // subR);
	    
	    -- These assertions are condition 4.1.
	    A := M^{i};
	    B := leadTerm fullSub H;
	    assert( H % subR == 0); -- H is an element of SubR^r.
	    assert( A - B == 0);

    	    f := sum(for j from 0 to (numcols currentGens)-1 list(H_(0,j)*(currentGens_(0,j)))); 
	    
	    --assert(f%subR == 0); 
	    hbar := intrinsicReduce(subR, S, f);
	    --assert(hbar%subR == 0);
	    
	    if hbar == 0 then(
		print("zero");
	    	continue;
		);
	    hbar = hbar * (1/(leadCoef hbar));
	    if member(hbar, encountered) then(
		print("not new...");
		);
	    print("New - (#terms:"|toString(numcols monomials hbar)|" degree:"|toString(degree hbar)|")");
	    encountered = encountered + set({hbar});
	    hbar
	    );
	print("-- total new generators:"|toString(length newGens));
			
    	if newGens == {} then (
	    print("-- No new gens found.");
    	    break;	
	    )else(
	    newGens = subR#"PresRing"#"InclusionBase"(matrix({newGens}));
	    currentGens = currentGens | newGens;
	    );
    	loopNum = loopNum + 1;
        );
    print("-- Computing normal form of generators...");    
    currentGens = currentGens // subR;        
    print("-- Computing autoreduction...");
    error "stop";
    reduced := for i from 0 to (numcols currentGens)-1 list(
	if (i % 10) == 0 then(
	    print(toString(i)|"/"|toString(numcols currentGens - 1));
	    );
	s := currentGens_(0,i);
	intrinsicReduce(subR, submatrix'(currentGens,,{i}), s)
	);
    matrix({reduced})
    );

-- For polynomial p monomial m, extract the coefficient of m in p. For example:
-- p = x*y*z + z*y^2 + 2x^2*y^2*z^2
-- m = x*y
-- Then:
-- p = (z+2x*y*z^2)*m + z*y^2 
-- monoCoef(p, m) = z+2x*y*z^2.
-- (Notice that the coefficient of the monomial m may involve m.)
-- (Also, if m has a coefficient other than one it will be ignored.)
monoCoef = method(TypicalValue => RingElement)
monoCoef(RingElement, RingElement) := (m, p) -> (
    
    -- This does not completley guarentee that they are elements of the same ring... 
    if ring m =!= ring p then (
	error "monoCoef expected m and p to be elements of the same ring.";
	);
    supp := support(m);
    R := ring(m);
    if numcols monomials m != 1 or supp == {} then(
	error "monoCoef expects m to be a non-constant monomial.";
	);
    -- remove the coefficient of m.
    m = toMonomial(ring m, first exponents m);

    monosP := monomials p;
    coefs := for i from 0 to (numcols monosP)-1 list(
	mono := monosP_(0,i);
	if gcd(m, mono) == leadTerm m then(
	    (coefficient(mono, p))*toMonomial(R, first ((exponents mono)-(exponents m)))
	    ) else(
	    0
	    )
	);
    sum coefs   
    );


-- !!! 	   This is a highly experimental function.     !!!
-- If M is the output of toricSyz, this produces a Subring instance and a 1-column 
-- matrix can be used with the function autoreduce. 
moduleToSubring = method()
moduleToSubring(Subring, Matrix) := (subR, M) -> (
    
    -- It requires subR to be a Sagbi basis so that it can run extra checks to verify
    -- assumptions about the properties of the resulting subring. 
    -- TODO: consider the implications of removing these checks so that this function
    -- can work when subR isn't a Sagbi basis.
    if not subR#"isSagbi" then(
	error "Only modules over Subring instances that are a sagbi basis are currently supported.";
	);
    
    if M%subR != 0 then(
	error "M is supposed to have entries that are elements of subR.";
	); 
    
    -- The value of these generators doesn't matter, but they should be increasing under
    -- the monomial order.
    tense := subR#"PresRing"#"TensorRing";
    dummy := for i from 1 to numcols M list( ((vars tense)_(0,0))^i );
    dummy = matrix({dummy});
    monoRing := subring(dummy);
    gVars := genVars(monoRing);
    
    M1 := subR#"PresRing"#"InclusionBase";
    M2 := monoRing#"PresRing"#"InclusionBase";
    
    result2 := ((M2 M1 M)*(transpose gVars));
        
    -- This call to sagbi should terminate quickly if subR is a Sagbi basis.    
    coolRing := sagbi subring ((M2 M1 gens subR)|gVars);    
    
    -- If either of these checks fail, it could mean that the monomial order on coolRing isn't behaving.
    if not coolRing#"isSagbi" then(
	error "Could not construct a sagbi basis of module's ring. ";
	);
    assert(result2%coolRing == 0);
    
    (coolRing, result2, gVars)
    );

-- Basically this is the inverse of moduleToSubring.
    -- M is a 1-column matrix that is probably the result of a call to moduleToSubring
    -- gVars is a 1-row matrix containing the variables that correspond to the generators of the module.
extractEntries = method()
extractEntries(Matrix, Matrix) := (M, gVars) -> (    
    -- Sorting is done to produce consistent behavior, but the monomial order on gVars is arbitrary.
    gVars = matrix({sort first entries gVars});
    mat := for i from 0 to (numrows M)-1 list(
    	apply(first entries gVars, var -> monoCoef(var, M_(i,0)))	
	);
    matrix(mat)
    );


-- Perform autoreduction on the generators of an intrinsic ideal:
-- I.e., reduce g\in idealGens modulo idealGens-g for all g\in idealGens.   
   -- subR is a Subring (probably has to be a Sagbi basis)
   -- idealGens is a matrix containing generators of an ideal in subR.
autoreduce = method(TypicalValue => Matrix)
autoreduce(Subring, Matrix) := (subR, idealGens) -> (
    noDupes := new MutableList from first entries idealGens;        
    reducedGens := for i from 0 to (numcols idealGens)-1 list(		
	s := idealGens_(0,i);
	notS := submatrix'(matrix({toList noDupes}),,{i});      
	print("----------- autoreduction step "|toString(i)|"/"|toString(numcols idealGens)|"  --------------");
	answer := intrinsicReduce(subR, notS, s);
       	answer = sub(answer,ring idealGens);
	noDupes#i = answer;	
	answer
	);
    -- The extra "matrix entries" is to eliminate the degrees (which are the numbers in curly brackets)
    -- I don't know what they are for and they break the == operator.
    matrix entries (transpose compress (matrix({reducedGens})))
    );

-- Performs autoreduction on M treated as a module over subR.
mingensSubring = method(TypicalValue => Matrix)
mingensSubring(Subring, Matrix) := (subR, M) -> (  
    (A, B, gVars)  := moduleToSubring(subR, M);
    debugPrintAllMaps(A);
    final := autoreduce(A, transpose B);
    final = extractEntries(final, gVars);
    subR#"PresRing"#"FullSub"(sub(final,subR#"PresRing"#"TensorRing"))
    );

-- This is subroutine 11.18 of Sturmfels.
-- Assumes M is a matrix of monomials in the toric ring K[A]
-- (for now,  it can be anything in the tensor ring of subR satisfying this condition,
-- involving the generators or the variables.)
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, M) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    incBase := pres#"InclusionBase";
    
    amb := ambient subR;
    r := numcols M;
    
    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if ring M === amb then(
	M = (pres#"InclusionBase")(M);
	) else if ring M =!= tense then(
	error "The entries of M must be in either the TensorRing or ambient ring of A.";
	);
    KA := subring leadTerm gens subR;
    tenseKA := KA#"PresRing"#"TensorRing";
    M = sub(M, tenseKA);    
    M = (KA#"PresRing"#"Substitution")(M);
    if leadTerm M != M then(
	error "Expected a 1-row matrix of monomials."; 
	); 
    
    U := M // KA;
    -- If some entry of M is not an element of KA, its normal form is zero.
    -- This will cause the assertion to fail.
    assert(KA#"PresRing"#"Substitution"(U) == M);

    -- each column of syzU is a relation of U.
    syzU := syz U;
    special := transpose syzU;
    
    -- U is supposed to in the upper variables only. 
    assert(KA#"PresRing"#"ProjectionInclusion" U == U);
    
    intersection := selectInSubring(1, gens gb intersect(ideal U, KA#"PresRing"#"LiftedPres"));    
    
    binomials := for i from 0 to (numcols intersection)-1 list(
	ent := intersection_(0,i);
	coefs := apply(first entries U, e -> monoCoef(e, ent));
      	if position(coefs, c -> c != 0) === null then (
	    error "Error: something impossible happened. (This may be a bug in the function toricSyz.)";
	    );
    	coefs 
	);
    binomials = (matrix binomials) || special;
    fullSubKA := KA#"PresRing"#"FullSub";
    binomials = transpose compress transpose fullSubKA binomials;
    matrix entries binomials
    --matrix entries transpose compress KA#"PresRing"#"FullSub"(gens gb (transpose (matrix entries binomials)//KA))
    
    );
