-- undocumented methods and symbols (for each, consider... does it really need to be exported? should it be documented?)
undocumented {
    }

doc ///
   Key
     SubalgebraBases
   Headline
     a package for finding canonical subalgebra bases (aka SAGBI bases)
   Description
    Text
      Let $R=k[f_1,\ldots,f_k]$ denote the subalgebra of the polynomial ring $k[x_1,\ldots,x_n]$ generated by $f_1,\ldots ,f_k.$ We say
      $f_1,\ldots,f_k$ form a {\it subalgebra basis} with respect to a monomial order $<$ if the {\it initial algebra}
      associated to $<$, defined as $in(R) := k[in(f) \mid f \in R],$ is generated by the elements
      $in(f_1), \ldots , in(f_k).$ 
    Text
      {\bf Some references for Subalgebra bases (aka canonical subalgebra bases, SAGBI bases)}

      @UL {
      "Kapur, D., Madlener, K. (1989). A completion procedure for computing a canonical basis of a $k$-subalgebra.
      Proceedings of Computers and Mathematics 89 (eds. Kaltofen and Watt), MIT, Cambridge, June 1989",
      "Robbiano, L., Sweedler, M. (1990). Subalgebra bases,
      in W.~Bruns, A.~Simis (eds.): Commutative Algebra,
      Springer Lecture Notes in Mathematics 1430, pp.~61--87",
      "F. Ollivier, Canonical Bases: Relations with Standard bases, finiteness
      conditions and applications to tame automorphisms, in Effective Methods
      in Algebraic Geometry, Castiglioncello 1990, pp. 379-400,
      Progress in Math. 94 Birkhauser, Boston (1991)",
      "B. Sturmfels, Groebner bases and Convex Polytopes, Univ. Lecture
      Series 8, Amer Math Soc, Providence, 1996"
      }@
   SeeAlso
     "SAGBI bases of subrings of quotient rings"
     "Experimental implementation of modules over subrings"
      
      
///

doc /// 
    Key
        "SAGBI bases of subrings of quotient rings"
    Description
        Text
          The SAGBI algorithm implementation used in this package was originally written by Mike Stillman in approximately 1999
	  for the purpose of implementing concepts from the paper "Using SAGBI bases to compute invariants" by Stillman and Tsai.
	  Namely, the purpose was to be capable of calculating Sagbi bases of subrings contained in quotient rings. 
	  
	  Although this purpose was not understood by later programmers, the code still retains this capability. However, there are
	  some pecularities. Consider the following example: 
	  
	Example
	  gndR = QQ[x,y, MonomialOrder => Lex];
	  I = ideal(x^2 - x*y);
	  Q = gndR/I;
	  subR = sagbi subring {x};
	  gens subR
	  
	Text 
	
	  Because $x^2 = xy$ inside of the quotient ring $\mathbb{Q}[x,y]/(x)$, the resulting Sagbi basis $(x)$ cannot be correct because
	  it does not involve $y$.
	
	  In this example, the algorithm terminated successfully because it has no way of knowing that $x^2 = xy$ inside of the
	  ambient ring of subR. Technically, one could argue that this isn’t a bug because it’s actually doing what it is
	  supposed to do according to the specification. Notice that the Sagbi algorithm’s proof of correctness in Proposition 3
	  of "Using SAGBI bases to compute invariants" by Stillman and Tsai does not apply when a finite Sagbi basis doesn’t exist. 
	  So, fixing this “bug” is really a question of whether or not it is possible to improve upon the underlying algorithm.
	  
	  What this means is that it is possible for the Sagbi algorithm to falsely succeed when the ambient ring is a quotient ring. 
	  However, when a finite SAGBI basis does happen to exist, the algorithm *should* be able to calculate it correctly given enough
	  time.
	  
	  The following is an example of a correct Sagbi computation over a subring of a quotient ring. It is an implementation of
	  Example 2 of Stillman and Tsai in the case $N=4$. 
	CannedExample
	  N = 4;
	  gndR = QQ[(a,b,c,d)|(u_1..u_N)|(v_1..v_N), MonomialOrder => Lex];
	  I = ideal(a*b - b*c - 1);
	  quot = gndR/I;
	  U = (vars quot)_{4..(N+3)}
	  V = (vars quot)_{(N+4)..(2*N+3)}
	  G = flatten for i from 0 to N-1 list(
    	      {a*(U_(0,i)) + b*(V_(0,i)), c*(U_(0,i)) + d*(V_(0,i))}
    	      );
	  sag = sagbi G
	  ans = matrix {{c*u_4+d*v_4, c*u_3+d*v_3, c*u_2+d*v_2, c*u_1+d*v_1, a*u_4+b*v_4, a*u_3+b*v_3, a*u_2+b*v_2,
     		  a*u_1+b*v_1, a*d*u_3*v_4-a*d*u_4*v_3-b*c*u_3*v_4+b*c*u_4*v_3,
     		  a*d*u_2*v_4-a*d*u_4*v_2-b*c*u_2*v_4+b*c*u_4*v_2, a*d*u_2*v_3-a*d*u_3*v_2-b*c*u_2*v_3+b*c*u_3*v_2,
     		  a*d*u_1*v_4-a*d*u_4*v_1-b*c*u_1*v_4+b*c*u_4*v_1, a*d*u_1*v_3-a*d*u_3*v_1-b*c*u_1*v_3+b*c*u_3*v_1,
     		  a*d*u_1*v_2-a*d*u_2*v_1-b*c*u_1*v_2+b*c*u_2*v_1}}
	  assert (gens sag == ans);
    SeeAlso
    	
///
doc /// 
    Key
        "Experimental implementation of modules over subrings"
    Description
        Text
	  In order to explain how modules over subrings are implemented in this package, it will be helpful to look at an example. 
	  The following is an implementation of Example 11.19 from "Groebner bases and Convex Polytopes" by Bernd Sturmfels:
        CannedExample
	  i = 2;
	  gndR = QQ[t_1, t_2, t_3];
	  A := {t_1*t_2*t_3,
		t_1^2*t_2,
		t_1*t_2^2,
		t_1^2*t_3,
		t_1*t_3^2,
		t_2^2*t_3,
		t_2*t_3^2};
	  G := matrix {{t_1^(2*i)*t_2^(2*i)*t_3^(2*i), t_1^((3*i)+2)*t_2*t_3^(3*i)}}
	  subR = sagbi subring A;
	  assert((set first entries gens subR) === (set A)); 
	  tsyz := toricSyz(subR, G);
	  assert(tsyz * (transpose G) == 0);

	  ans1 = mingensSubring(subR, tsyz);  
	Text
	  The resulting value of ans1 and its normal form are:
	CannedExample
	  i13 : ans1

	  o13 = | t_1^4t_3^5    -t_2^3t_3^3    |
		| t_1^4t_2t_3^4 -t_2^4t_3^2    |
		| t_1^5t_3^4    -t_1t_2^3t_3^2 |
		| t_1^5t_2t_3^3 -t_1t_2^4t_3   |
		| t_1^6t_3^3    -t_1^2t_2^3t_3 |
		| t_1^6t_2t_3^2 -t_1^2t_2^4    |
		| t_1^4t_3^8    -t_2^3t_3^6    |

			7       2
	  o13 : Matrix R  <--- R
	  
	  i14 : ans1//subR

	  o14 = | p_4^2p_7  -p_3p_5 |
	       | p_4^2p_9  -p_5^2  |
	       | p_4p_7^2  -p_3p_8 |
	       | p_4p_7p_9 -p_5p_8 |
	       | p_7^3     -p_5p_9 |
	       | p_7^2p_9  -p_8^2  |
	       | p_4^4     -p_3^3  |

				  7                  2
	  o14 : Matrix (QQ[p ..p ])  <--- (QQ[p ..p ])
			   0   9              0   9
    	Text
	  This appears to agree with Sturmfels's prediction, although it is not possible to be entirely certain that this computation
	  is correct without knowing more than the information contained in the Sturmfels text. This is because Sturmfels does not 
	  fully specify what the set of minimal generators of this syzygy module are. Namely, it is only stated that it must include
	  $2i+2=6$ syzygies of total degree $i+1 = 3$.
	
	  The following code is the implementation of the function @TT "mingensSubring"@:
	  
	CannedExample	
	  -- Performs autoreduction on M treated as a module over subR.
	  mingensSubring = method(TypicalValue => Matrix)
	  mingensSubring(Subring, Matrix) := (subR, M) -> (  
	      (A, B, gVars)  := moduleToSubringIdeal(subR, M);
	      final := autoreduce(A, transpose B);
	      -- Sort the rows of the matrix for more predictable behavior.
	      final = matrix transpose {sort first entries transpose final};
	      final = extractEntries(final, gVars);
	      subR#"PresRing"#"FullSub"(sub(final,subR#"PresRing"#"TensorRing"))
	      );
	Text
	   The function @TT "mingensSubring"@ works by converting the given matrix (which should be thought of as a module) to an 
	   ideal inside of a subring, and then performing autoreduction on the generators of that ideal. It relies on the function
	   @TT "moduleToSubringIdeal"@ to construct a suitable subring and provide the generators that define this ideal.
	   
	   In order to understand how the function @TT "moduleToSubringIdeal"@ works, one must first understand the @TO "Subring"@ type.
	   Consider the output of the following command:
	CannedExample
	  i5 : debugPrintMap (subR#"PresRing"#"FullSub")
	  maps p_0 to t_1
	  maps p_1 to t_2
	  maps p_2 to t_3
	  maps p_3 to t_2*t_3^2
	  maps p_4 to t_1*t_3^2
	  maps p_5 to t_2^2*t_3
	  maps p_6 to t_1*t_2*t_3
	  maps p_7 to t_1^2*t_3
	  maps p_8 to t_1*t_2^2
	  maps p_9 to t_1^2*t_2
        Text
	  
	  @TT "p_1"@, ..., @TT "p_9"@ are the variables of what is refered to in the code as the "TensorRing". The @TT "TensorRing"@ of @TT "subR"@ has two parts:
	  the "lower variables," and the "upper variables."
	  
	  The variables @TT "p_0"@, @TT "p_1"@ and @TT "p_2"@ are the lower variables of subR#"PresRing". They correspond to the variables of the "ambient ring"
	  of @TT "subR"@, which is @TT "gndR"@ in our original example. The upper variables of @TT "subR"@ are @TT "p_3"@, ..., @TT "p_9"@. These correspond to
	  generators of the subring.
	  
	  The following command converts the toric syzygy module from our example (which is returned by @TT "toricSyz"@ in the form of a matrix) to an ideal 
	  within a subring. This is identical to the @TT "moduleToSubring(subR, tsyz)"@ call that occurs in the first line of @TT "mingensSubring"@. 
	CannedExample
	   i15 : (modRing, idealGens, gVars) = moduleToSubringIdeal(subR, tsyz)

	   o15 = (subring of QQ[p_0..p_11], | -p_0^6p_2^3p_10+p_0^2p_1^3p_2p_11   |, | p_10 p_11 |)
					    | -p_0^6p_1p_2^2p_10+p_0^2p_1^4p_11   |
					    | -p_0^6p_2^3p_10+p_0^2p_1^3p_2p_11   |
					    | -p_0^5p_1p_2^3p_10+p_0p_1^4p_2p_11  |
					    | -p_0^5p_2^4p_10+p_0p_1^3p_2^2p_11   |
					    | -p_0^5p_2^4p_10+p_0p_1^3p_2^2p_11   |
					    | -p_0^4p_1p_2^4p_10+p_1^4p_2^2p_11   |
					    | -p_0^4p_2^5p_10+p_1^3p_2^3p_11      |
					    | p_0^8p_2^4p_10-p_0^4p_1^3p_2^2p_11  |
					    | -p_0^7p_2^5p_10+p_0^3p_1^3p_2^3p_11 |
					    | -p_0^5p_2^7p_10+p_0p_1^3p_2^5p_11   |
					    | -p_0^4p_2^8p_10+p_1^3p_2^6p_11      |
					    | -p_0^6p_2^6p_10+p_0^2p_1^3p_2^4p_11 |
					    
	   i16 : debugPrintMap(modRing#"PresRing"#"FullSub")
	   maps p_0 to p_0
	   maps p_1 to p_1
	   maps p_2 to p_2
	   maps p_3 to p_3
	   maps p_4 to p_4
	   maps p_5 to p_5
	   maps p_6 to p_6
	   maps p_7 to p_7
	   maps p_8 to p_8
	   maps p_9 to p_9
	   maps p_10 to p_10
	   maps p_11 to p_11
	   maps p_12 to p_10
	   maps p_13 to p_11
	   maps p_14 to p_1*p_2^2
	   maps p_15 to p_0*p_2^2
	   maps p_16 to p_1^2*p_2
	   maps p_17 to p_0*p_1*p_2
	   maps p_18 to p_0^2*p_2
	   maps p_19 to p_0*p_1^2
	   maps p_20 to p_0^2*p_1
    	Text
	  The ambient ring of @TT "modRing"@ is the tensor ring of @TT "subR"@, except two new variables @TT "p_10"@ and @TT "p_11"@ have been added.
	  The variables @TT "p_10"@ and @TT "p_11"@ correspond to the generators of the module. The generators @TT "p_12"@ and @TT "p_13"@ also correspond
	  to the generators of the module, except they are upper rather than lower variables. 
	  
	  @UL {"a",
	      "b"
	      }@

	  	 
    SeeAlso
      (moduleToSubringIdeal, Subring, Matrix)
      (mingensSubring, Subring, Matrix)
///






doc ///
   Key
     subalgebraBasis
     (subalgebraBasis,Subring)
     (subalgebraBasis, Matrix)
     (subalgebraBasis, List)
     [subalgebraBasis,Limit]
     [subalgebraBasis,PrintLevel]
     [subalgebraBasis,Strategy]
   Headline
     subalgebra basis (sagbi basis)
   Usage
     N = subalgebraBasis M
     N = subalgebraBasis A
     N = subalgebraBasis L
   Inputs
     A:Subring
     M:Matrix
       of generators for a subring of @ ofClass{PolynomialRing} @
     L:List
       containing generators for a subring of @ ofClass{PolynomialRing} @
     Limit=>ZZ
       a degree limit for the binomial "S-pairs" that are computed internally
     PrintLevel=>ZZ
     Strategy=>String
       not currently used
   Outputs
     N:Matrix
       whose entries form a partial subalgebra basis
   Description
    Text
        The output of this function is generally a partial subalgebra basis. This is unavoidable, since a subalgebra of a polynomial ring, endowed with some polynomial order, need not have a finite subalgebra basis. Here is a quintessential example of this phenomenon.
    Example
      R=QQ[x,y];
      A = subring matrix{{x+y,x*y,x*y^2}};
      subalgebraBasis(A,Limit=>3)
      subalgebraBasis(A,Limit=>10)
    Text
        Nevertheless, a finite subalgebra basis exists for many notable examples. 
        The following computation verifies a special case of Theorem 3.3 in "SAGBI bases with applications to blow-up algebras" by Conca, Herzog, and Valla.
    Example
        R=QQ[t,z_1..z_4,MonomialOrder=>{Weights=>{1,0,0,0,0},Lex}];
        M=matrix{{z_1,z_2,z_3},{z_2,z_3,z_4}};
        I=minors(2,M);
        A=subring(drop(gens R,1) | apply(I_*, p -> t* p))
        subalgebraBasis(A, PrintLevel => 1)
    Text
        Continuing with this example, we illustrate how the setting the option Limit may influence the output.
    Example
        subalgebraBasis(A, PrintLevel => 1, Limit=>1)
        subalgebraBasis(A, PrintLevel => 1, Limit=>6)
    Text
        The output of the last command is a finite Subalgebra Basis, but the computation necessary to verify this fact required setting Limit to at least 7.
   Caveat
   SeeAlso
///

doc ///
   Key
     (subduction, Subring, RingElement)
   Headline
     Perform subduction on an element of a ring.
   Usage
     result = subduction(subR, f)
   Inputs
     subR:Subring
       must have a previously computed Sagbi basis.
     f:RingElement
       an element of the ambient ring of subR.
   Outputs
     result:RingElement
       f after subduction has been performed.	
   Description
     Text
       Performs subduction. Will throw an error if f is not a member of the ambient ring of subR or subR does not have a cached Sagbi basis.
   SeeAlso
     (symbol %, RingElement, Subring)
///


doc ///
   Key
     (symbol %, RingElement, Subring)
   Headline
     remainder modulo a subring
   Usage
     r = f % A
   Inputs
     f:RingElement
       an element of the ambient ring of $A$ (endowed with some monomial order.)
     A:Subring
   Outputs
     r:RingElement
       The normal form of f modulo $A$
   Description
     Text
       The result $r$ is zero if and only if $f$ belongs to $A$.
     Example
       R = QQ[x1, x2, x3];
       A = subring {x1+x2+x3, x1*x2+x1*x3+x2*x3, x1*x2*x3, (x1-x2)*(x1-x3)*(x2-x3)} --usual invariants of A_3
       f = x1 + x2 + 2*x3
       f % A
       g = x1^2*x2 + x2^2*x3 + x3^2*x1
       g % A
   SeeAlso
    Subring
    subring
///


doc ///
   Key
     Subring
   Description
     Text
       An instance of the type Subring consists an ambient polynomial ring, a matrix of generators, and a cache Table that stores computations relevant for subalgebra bases. The cache table facillitates operations such as membership testing.
   Caveat
   SeeAlso
       subring
       (gens, Subring)
       (ambient, Subring)
       subalgebraBasis
///

-*
doc ///
  Key
    setWeight
    (setWeight,Subring, List)
  Headline
    sets weight for ambient ring of a Subring
  Usage
    setWeight(A, W)
  Inputs
    A:Subring
    W:List
      a weight vector of the ambient ring of A
  Description
    Text
      Setting the weight vector allows the Subring to construct a lifted weight 
      vector which is applied to the presentation ring of A.
      In order to apply this weight vector to the presentation of A successfully, 
      setWeight must be used before presentationRing and presentation.
      In this example we set the weight of ambient ring of the Pl\"ucker algebra
      for Grassmannian(2, 4) such that the leading term of any maximal minor is 
      the leading term.
    Example
      (n, k) = (4, 2);
      D = toList apply((1,1) .. (k,n), (i,j) -> n*k - (n-j)*(i-1)) -- Diagonal weight vector 
      R = QQ[x_(1,1) .. x_(k,n)];
      X = transpose genericMatrix(R, n, k);
      M = matrix { for J in subsets(n, k) list det X_J };
      A = subring M; -- Plucker algebra
      setWeight(A, D)
      S = presentationRing(A, QQ[apply(toSequence\subsets(n, k), J -> p_J)])
      I = presentation A
      leadTerm(1, I)
  SeeAlso
    Subring
    subring
    getWeight
    presentationRing
    presentation
///
*-

doc ///
   Key
     subring
     (subring, List)
     (subring, Matrix)
   Headline
     Constructs a subring of a polynomial ring
   Usage
     A = subring M
   Inputs
     M:Matrix
       A one row matrix whose entries come from @ ofClass{PolynomialRing} @
     L:List 
       whose entries come from @ ofClass{PolynomialRing} @
   Outputs
     A:Subring
   Description
    Text
      A @ ofClass{Subring} @ stores the ambient polynomial ring, a matrix of the given generators, and a cache table with intermediate
    Example
       R = QQ[x];
       A = subring {x^4+x^3, x^2+x}
       member(x^3+x^2, A)
   Caveat
     The ambient ring and the generators are immutable values. A method for @TO "==" @ is currently not implemented.
   SeeAlso
     Subring
///

doc ///
   Key
     autoreduce
     (autoreduce, Subring, Matrix)
   Headline
     Perform autoreduction of the generators of an ideal of a subring.
   Usage
     result = subduction(subR, idealGens)
   Inputs
     subR:Subring
       A subring instance that is a sagbi basis.
     idealGens:Matrix
       A one-row matrix whose entries are the elements of subR considered as generators of an ideal $I$. 
   Outputs
     result:Matrix
       The reduced generators of the ideal generated by the entries of M.
   Description
     Text
       Performs autoreduction on the generators of an ideal within a subring.
       
       Each generator $g\in M$ is replaced with the normal form of $g$ relative to $M\setminus \{g\}$, computed using
       the function @TO "intrinsicReduce"@.

   SeeAlso
     (autosubduce, Subring)
///


doc ///
   Key
     autosubduce
     (autosubduce, Subring)
   Headline
     Performs autosubduction on the generators of a subring.
   Usage
     result = subduction(subR)
   Inputs
     subR:Subring
    	A subring that need not be a sagbi basis. 
   Outputs
     result:Subring
       A subring generated by the autosubduced generators of subR.
   Description
     Text
       Replaces each generator $g$ of subR with the result of subducing $g$ modulo (gens subR)$\setminus \{g\}$.
       
   SeeAlso
     (autoreduce, Subring, Matrix)
     (subduction, Subring, RingElement)
///

doc ///
   Key
     debugPrintAllMaps
     (debugPrintAllMaps, Subring)
   Headline
     Prints the maps associated with a subring.
   Usage
     debugPrintAllMaps(subR)
   Inputs
     subR:Subring
    	any subring.
   Outputs
   Description
     Text
       Prints a summary of the maps associated with a Subring instance.
       
       It is easy to get confused about what the various maps and rings stored inside of a Subring instance are. 
              
       Although not strictly neccessary, this function makes this package easier to learn and debug. 
       
     Example 
       R = QQ[t_1, t_2];
       subR = subring matrix(R, {{t_1^2, t_1*t_2, t_2^2}});
       debugPrintAllMaps(subR)
   SeeAlso
     (debugPrintAllMaps, Subring)
     (debugPrintGens, Subring)
     (debugPrintMap, RingMap)
     (debugPrintMat, Matrix)
///

doc ///
   Key
     debugPrintGens
     (debugPrintGens, Subring)
   Headline
     Prints the generators of a subring.
   Usage
     debugPrintGens(subR)
   Inputs
     subR:Subring
    	any subring.
   Outputs
   Description
     Text
       Prints the generators of a subring in a human readable-format.
       
       The optional argument @TO "StrWidth"@ determines the maximum number of characters to print in a single line.
       Polynomials whose net representation is wider than @TO "StrWidth"@ characters are cut off.
              
     Example 
       R = QQ[t_1, t_2];
       subR = subring matrix(R, {{t_1^2, t_1*t_2, t_2^2}});
       debugPrintGens(subR)
   SeeAlso
     (debugPrintAllMaps, Subring)
     (debugPrintGens, Subring)
     (debugPrintMap, RingMap)
     (debugPrintMat, Matrix)
///

doc ///
   Key
     debugPrintMap
     (debugPrintMap, RingMap)
   Headline
     Prints a RingMap in human-readable format.
   Usage
     debugPrintGens(f)
   Inputs
     f:RingMap
    	any RingMap.
   Outputs
   Description
     Text
       Prints a single RingMap in a human-readable format.
     Example 
       R = QQ[t_1, t_2];
       subR = subring matrix(R, {{t_1^2, t_1*t_2, t_2^2}});
       debugPrintMap(subR#"PresRing"#"Substitution")
   SeeAlso
     (debugPrintAllMaps, Subring)
     (debugPrintGens, Subring)
     (debugPrintMap, RingMap)
     (debugPrintMat, Matrix)
///

doc ///
   Key
     debugPrintMat
     (debugPrintMat, Matrix)
   Headline
     Prints a one-row matrix of in human-readable format.
   Usage
     debugPrintMat(M)
   Inputs
     M:Matrix
    	A one row-matrix.
   Outputs
   Description
     Text
       Given a one row matrix of (potentially very large) polynomials, prints each entry in human-readable format.
       
       The optional argument @TO "StrWidth"@ determines the maximum number of characters to print in a single line.
       Polynomials whose net representation is wider than @TO "StrWidth"@ characters are cut off.

     Example 
       R = QQ[t_1, t_2];
       debugPrintMat(matrix {{t_1^2, t_1*t_2, t_2^2}})
   SeeAlso
     (debugPrintAllMaps, Subring)
     (debugPrintGens, Subring)
     (debugPrintMap, RingMap)
     (debugPrintMat, Matrix)
///

doc ///
   Key
     extractEntries
     (extractEntries, Matrix, Matrix)
   Headline
     Can be thought of as the inverse of moduleToSubringIdeal
   Usage
     extractEntries(M, gVars)
   Inputs
     M:Matrix
    	A 1-column matrix that is probably the result of a call to moduleToSubringIdeal.
     gVars:Matrix 
        A 1-row matrix containing the variables that correspond to the generators of the module.
   Outputs
     result:Matrix
        
   Description
     Text
         
       Converts elements of a subring ideal (represented by a one-column matrix) to elements 
       of a module (represented by a matrix.)

       Internally, the argument gVars is sorted so that the order of the columns of the resulting
       matrix is consistent.
       
     Example 
       R = QQ[a, b, c, x_1, x_2, x_3];
       extractEntries(matrix {{a*x_1 + b*x_2 + c*x_3}}, matrix {{x_1, x_2, x_3}})
       extractEntries(matrix {{a*x_1 + b*x_2 + c*x_3},{a*x_1 + a*x_2 + a*x_3}}, matrix {{x_1, x_2, x_3}} )
   SeeAlso
     (moduleToSubringIdeal, Subring, Matrix)
///


doc ///
   Key
     extrinsicBuchberger
     (extrinsicBuchberger, Subring, Matrix)
   Headline
     Computes a Gröbner basis of an ideal within a Subring.
   Usage
     extrinsicBuchberger(M, gVars)
   Inputs
     M:Matrix
    	A 1-column matrix that is probably the result of a call to moduleToSubringIdeal.
     gVars:Matrix 
        A 1-row matrix containing the variables that correspond to the generators of the module.
   Outputs
     result:Matrix
        
   Description
     Text
       This is an implementation of Algorithm 11.24 of "Gröbner Bases and Convex Polytopes" by Bernd Sturmfels. (DOI: 
       http://dx.doi.org/10.1090/ulect/008)
       
       To understand how this function works, recall computing a Gröbner Basis can be thought of as a generalization
       of Gaussian elimination. This function works the same way as the function @TO (groebnerBasis,Matrix)@, except
       the "field of scalars" is a subring.
///

doc ///
   Key
     genVars
     (genVars, Subring)
   Headline
     Returns the variables corresponding to the subalgebra generators in the tensor ring.
   Usage
     result = gevVars(subR)
   Inputs
     subR:Subring
   Outputs
     result:Matrix
   Description
     Text
       This returns the "upper variables" of the tensor ring of a @TO "Subring"@ instance. These variables correspond to
       generators of the subring.
     Example
       R = QQ[t_1, t_2, t_3];
       A := {t_1*t_2*t_3, t_1^2*t_2, t_1*t_2^2, t_1^2*t_3, t_1*t_3^2, t_2^2*t_3, t_2*t_3^2};
       subR = subring A;
       genVarsSubR = genVars subR
       subR#"PresRing"#"Substitution"(genVarsSubR)
///

doc ///
   Key
     intrinsicReduce
     (intrinsicReduce, Subring, Matrix, RingElement)
   Headline
     Calculates the normal form of an element of an ideal of a subring.
   Usage
     result = intrinsicReduce(subR, G, p)
   Inputs
     subR:Subring
     	 A subring that contains the ideal generated by the 1-row matrix G.
     G:Matrix
     	 Generators of an ideal of subring. The entries may be contained in the tensor ring or ambient ring of subR. 
     p:RingElement
     	 An element of subR#"PresRing"#"TensorRing", which is an element of the subring subR.
   Outputs
     result:RingElement
   Description
     Text
       This is an implementation of Algorithm 11.14 of "Gröbner Bases and Convex Polytopes" by Bernd Sturmfels. (DOI: 
       http://dx.doi.org/10.1090/ulect/008)
   
       This function calculates the normal form of an element of an ideal within a subring.
///


doc ///
   Key
     isSubalg
     (isSubalg, Subring, Subring)
   Headline
     Calculates whether a given subring is contained in another subring.
   Usage
     result = intrinsicReduce(A, B)
   Inputs
     A:Subring
     B:Subring
   Outputs
     result:Boolean
    	Whether or not the subring A is contained in the subring B. 
   Description
     Text
       This function tests that each of the generators of the subring A have a normal form of zero with respect to B.
     Example
       R = QQ[t_1, t_2]
       A = subring matrix(R, {{t_1^2, t_1*t_2}});
       B = subring matrix(R, {{t_1^2, t_1*t_2, t_2^2}});
       isSubalg(A,B)
///

doc ///
   Key
     leadCoef
     (leadCoef, RingElement)
   Headline
     Returns the coefficient of the lead monomial of f.
   Usage
     result = leadCoef(f)
   Inputs
     f:RingElement
   Outputs
     result:Thing
    	The coefficient of the lead monomial of f.
   Description       
     Example
       R = QQ[t_1, t_2];
       f = 5*t_1^2 + 7*t_2^2;
       leadCoef(f)
///

doc ///
   Key
     makePresRing
     (makePresRing, Ring, Matrix)
   Headline
     Contstructs an instance of the PresRing type
   Usage
     result = leadCoef(f)
   Inputs
     f:RingElement
   Outputs
     result:Thing
    	The coefficient of the lead monomial of f.
   Description
     Text 
       There are very few situations where it is recommended to use this function directly. As a rule of thumb, do not use
       this function if it is possible to use the function @TT "subring"@ instead.
       
       The reason why this is exported is for extensibility purposes. Having access to @TT "makePresRing"@ makes it easier
       to implement functions that have complete control over the data within a @TT "Subring"@ instance. 
       
       For example, this function is used in the implementation of @TO "sagbi"@ because there it is neccessary to create an
       instance of the @TO "Subring"@ type with a very specific state. 
///


doc ///
   Key
     mingensSubring
     (mingensSubring, Subring, Matrix)
   Headline
     Given a matrix that is considered as a module over a subring, this performs autoreduction on its generators.
   Usage
     result = mingensSubring(subR, M)
   Inputs
     subR:Subring
     M:Matrix
   Outputs
     result:Thing
    	The autoreduced generators of the given module.
   Description
     Text 
       This function converts the matrix M to a subring ideal, performs autoreduction on the generating set of that ideal, 
       and then returns the result in the form of a matrix.
///

doc ///
   Key
     moduleToSubringIdeal
     (moduleToSubringIdeal, Subring, Matrix)
   Headline
     Convert a module stored as a matrix to a subring ideal.
   Usage
     result = mingensSubring(subR, M)
   Inputs
     subR:Subring
     	 A subring that is a sagbi basis.
     M:Matrix
     	 A matrix whose entries are containing are elements of subR. 
   Outputs
     moduleSubR:Subring
        A subring 
     result2:Matrix
     	A one-column matrix whose entries are the generators of the subring ideal.
     gVars:Matrix
     	A one-row matrix whose entries are the generators of the module.
   Description
     Text 
       This function is highly experimental and is somewhat of a hack. 
       
///
